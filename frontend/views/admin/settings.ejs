<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Settings | Memofy</title>
    <link rel="stylesheet" href="/css/admin-dash.css">
    <link rel="stylesheet" href="/css/settings.css">
    <link rel="stylesheet" href="/css/admintopbar.css">
    <link rel="stylesheet" href="/css/settings.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <!-- Google Analytics Tracking -->
    <%- include('google-analytics', { propertyId: typeof gaPropertyId !== 'undefined' ? gaPropertyId : null }); %>

    <!-- SweetAlert2 -->
    <%- include('../../components/sweetalert2'); %>

    <script src="/js/lucide.min.js"></script>
    <script>
        // Immediate check on page load - redirect if password was changed
        (function() {
            if (sessionStorage.getItem('passwordChanged') === 'true') {
                sessionStorage.removeItem('passwordChanged');
                window.location.href = '/auth/logout';
            }
        })();
    </script>
</head>

<body data-current-user='<%- JSON.stringify({
    id: user._id,
    email: user.email,
    role: user.role,
    firstName: user.firstName,
    lastName: user.lastName,
    department: user.department || "",
    preferences: user.preferences || {}
}) %>'>

    <!-- Vue Components -->
    <script>
        /* global Swal */
        // Setting Toggle Component
        const SettingToggle = {
            props: {
                title: String,
                description: String,
                modelValue: Boolean,
                settingKey: String,
                loading: Boolean
            },
            emits: ['update:modelValue'],
            methods: {
                handleToggle() {
                    this.$emit('update:modelValue', !this.modelValue);
                }
            },
            template: `
                <div class="setting-row">
                    <div class="setting-info">
                        <h4>{{ title }}</h4>
                        <p>{{ description }}</p>
                    </div>
                    <label class="switch">
                        <input
                            type="checkbox"
                            :checked="modelValue"
                            @change="handleToggle"
                            :disabled="loading">
                        <span class="slider" :class="{ loading: loading }"></span>
                    </label>
                </div>
            `
        };

        // Feedback Message Component
        const FeedbackMessage = {
            props: {
                message: String,
                type: String, // 'success', 'error', 'info'
                show: Boolean
            },
            computed: {
                messageClass() {
                    return `settings-feedback ${this.type}`;
                }
            },
            template: `
                <div v-if="show" :class="messageClass" role="status">
                    {{ message }}
                </div>
            `
        };

        // Password Strength Indicator Component
        const PasswordStrength = {
            props: {
                password: String
            },
            computed: {
                strength() {
                    if (!this.password) return { level: 0, text: '' };

                    let score = 0;
                    const password = this.password;

                    // Length check
                    if (password.length >= 8) score += 1;
                    if (password.length >= 12) score += 1;

                    // Character variety
                    if (/[a-z]/.test(password)) score += 1;
                    if (/[A-Z]/.test(password)) score += 1;
                    if (/[0-9]/.test(password)) score += 1;
                    if (/[^a-zA-Z0-9]/.test(password)) score += 1;

                    const levels = [
                        { level: 0, text: 'Very Weak', class: 'very-weak' },
                        { level: 1, text: 'Weak', class: 'weak' },
                        { level: 2, text: 'Fair', class: 'fair' },
                        { level: 3, text: 'Good', class: 'good' },
                        { level: 4, text: 'Strong', class: 'strong' },
                        { level: 5, text: 'Very Strong', class: 'very-strong' }
                    ];

                    return levels[Math.min(score, 5)] || levels[0];
                }
            },
            template: `
                <div v-if="password" class="password-strength">
                    <div class="strength-bar">
                        <div
                            :class="['strength-fill', strength.class]"
                            :style="{ width: (strength.level / 5) * 100 + '%' }">
                        </div>
                    </div>
                    <span class="strength-text">{{ strength.text }}</span>
                </div>
            `
        };
    </script>

    <!-- Main Vue App -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const { createApp, ref, computed, watch, onMounted } = Vue;

            const app = createApp({
                components: {
                    SettingToggle,
                    FeedbackMessage,
                    PasswordStrength
                },
                setup() {
                    // Reactive state
                    const currentUser = ref({});
                    const loading = ref(false);
                    const saving = ref({});

                    // Password form
                    const passwordForm = ref({
                        currentPassword: '',
                        newPassword: '',
                        confirmPassword: ''
                    });
                    const passwordFeedback = ref({
                        show: false,
                        message: '',
                        type: ''
                    });

                    // Settings state
                    const settings = ref({
                        darkMode: false,
                        twoFactorEnabled: false,
                        sessionTimeout: 30,
                        notifications: {
                            memoEmails: true,
                            profileUpdates: false
                        }
                    });

                    // Initialize from data attributes (basic info; settings come from /api/settings)
                    try {
                        const userData = document.body.getAttribute('data-current-user');
                        if (userData) {
                            currentUser.value = JSON.parse(userData);
                        }
                    } catch (err) {
                        console.error('Error parsing user data:', err);
                    }

                    // Computed properties
                    const passwordsMatch = computed(() => {
                        return passwordForm.value.newPassword === passwordForm.value.confirmPassword;
                    });

                    const isPasswordValid = computed(() => {
                        return passwordForm.value.newPassword.length >= 8 && passwordsMatch.value;
                    });

                    // Methods
                    const updatePassword = async () => {
                        if (!isPasswordValid.value) {
                            showFeedback('password', 'Please ensure passwords match and are at least 8 characters long.', 'error');
                            return;
                        }

                        loading.value = true;
                        try {
                            const response = await fetch('/api/password/change', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'same-origin',
                                body: JSON.stringify({
                                    currentPassword: passwordForm.value.currentPassword,
                                    newPassword: passwordForm.value.newPassword,
                                    confirmPassword: passwordForm.value.confirmPassword
                                })
                            });

                            const data = await response.json();

                            if (data.success) {
                                // Clear form first
                                passwordForm.value = {
                                    currentPassword: '',
                                    newPassword: '',
                                    confirmPassword: ''
                                };
                                // Show SweetAlert with re-login info and then force logout on confirm
                                const msg = data.message || 'Your password has been updated successfully.';
                                showFeedback('password', `${msg} Please log in again with your new password.`, 'success');
                            } else {
                                showFeedback('password', data.message || 'Failed to update password', 'error');
                            }
                        } catch (error) {
                            console.error('Error updating password:', error);
                            showFeedback('password', 'Failed to update password. Please try again.', 'error');
                        } finally {
                            loading.value = false;
                        }
                    };

                    const updateSetting = async (key, value) => {
                        saving.value[key] = true;

                        // Build payload expected by /api/settings
                        let payload = {};
                        if (key === 'darkMode' || key === 'twoFactorEnabled') {
                            payload[key] = value;
                        } else if (key === 'notifications.memoEmails' || key === 'notifications.profileUpdates') {
                            const notifKey = key.split('.')[1]; // 'memoEmails' or 'profileUpdates'
                            payload.notifications = { [notifKey]: value };
                        }

                        try {
                            const response = await fetch('/api/settings', {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'same-origin',
                                body: JSON.stringify(payload)
                            });

                            const data = await response.json();

                            if (!data.success) {
                                // Revert the change if failed
                                if (key === 'darkMode' || key === 'twoFactorEnabled') {
                                    settings.value[key] = !value;
                                } else if (key.startsWith('notifications.')) {
                                    const notifKey = key.split('.')[1];
                                    settings.value.notifications[notifKey] = !value;
                                }
                                showFeedback('settings', data.message || `Failed to update ${key}`, 'error');
                            } else {
                                // Sync local settings with server-normalized values if provided
                                if (data.settings) {
                                    settings.value.darkMode = !!data.settings.darkMode;
                                    settings.value.twoFactorEnabled = !!data.settings.twoFactorEnabled;
                                    if (data.settings.notifications) {
                                        settings.value.notifications = {
                                            memoEmails: !!data.settings.notifications.memoEmails,
                                            profileUpdates: !!data.settings.notifications.profileUpdates
                                        };
                                    }
                                }
                                showFeedback('settings', 'Settings updated successfully!', 'success');
                            }
                        } catch (error) {
                            console.error('Error updating setting:', error);
                            if (key === 'darkMode' || key === 'twoFactorEnabled') {
                                settings.value[key] = !value;
                            } else if (key.startsWith('notifications.')) {
                                const notifKey = key.split('.')[1];
                                settings.value.notifications[notifKey] = !value;
                            }
                            showFeedback('settings', 'Failed to update settings', 'error');
                        } finally {
                            saving.value[key] = false;
                        }
                    };

                    const updateSessionTimeout = async () => {
                        saving.value.sessionTimeout = true;

                        try {
                            const response = await fetch('/api/settings', {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'same-origin',
                                body: JSON.stringify({
                                    sessionTimeoutMinutes: settings.value.sessionTimeout
                                })
                            });

                            const data = await response.json();

                            if (data.success) {
                                showFeedback('session', 'Session timeout updated successfully!', 'success');
                            } else {
                                showFeedback('session', data.message || 'Failed to update session timeout', 'error');
                            }
                        } catch (error) {
                            console.error('Error updating session timeout:', error);
                            showFeedback('session', 'Failed to update session timeout', 'error');
                        } finally {
                            saving.value.sessionTimeout = false;
                        }
                    };

                    const showFeedback = (type, message, feedbackType = 'info') => {
                        const feedbackMap = {
                            settings: () => showTempFeedback('settings', message, feedbackType)
                        };

                        if (type === 'password' || type === 'session') {
                            const isPassword = type === 'password';
                            const icon = feedbackType === 'success' ? 'success' : (feedbackType === 'error' ? 'error' : 'info');
                            if (typeof Swal !== 'undefined') {
                                const swalConfig = {
                                    icon,
                                    title: feedbackType === 'success'
                                        ? (isPassword ? 'Password Updated' : 'Session Timeout Updated')
                                        : (isPassword ? 'Password Update' : 'Session Timeout'),
                                    text: message,
                                    confirmButtonText: isPassword && feedbackType === 'success' ? 'Reâ€‘login' : 'OK',
                                    confirmButtonColor: feedbackType === 'success' ? '#2563EB' : undefined,
                                    allowOutsideClick: false,
                                    allowEscapeKey: false,
                                    showCancelButton: false
                                };

                                // For password success, make it non-dismissible
                                if (isPassword && feedbackType === 'success') {
                                    swalConfig.allowOutsideClick = false;
                                    swalConfig.allowEscapeKey = false;
                                    swalConfig.showCancelButton = false;
                                    // Mark that password was changed - user must re-login
                                    sessionStorage.setItem('passwordChanged', 'true');
                                }

                                Swal.fire(swalConfig).then((result) => {
                                    if (isPassword && feedbackType === 'success' && result.isConfirmed) {
                                        // Clear the flag and force re-login after password change
                                        sessionStorage.removeItem('passwordChanged');
                                        window.location.href = '/auth/logout';
                                    }
                                });
                            } else {
                                alert(message);
                                if (isPassword && feedbackType === 'success') {
                                    sessionStorage.setItem('passwordChanged', 'true');
                                    window.location.href = '/auth/logout';
                                }
                            }
                        } else if (feedbackMap[type]) {
                            feedbackMap[type](message, feedbackType);
                        }
                    };

                    const showTempFeedback = (elementId, message, type) => {
                        const element = document.getElementById(elementId + 'Feedback');
                        if (element) {
                            element.textContent = message;
                            element.className = `settings-feedback ${type}`;
                            element.style.display = 'block';

                            setTimeout(() => {
                                element.style.display = 'none';
                            }, 3000);
                        }
                    };

                    // Watchers for automatic setting updates
                    watch(() => settings.value.notifications.memoEmails, (newVal) => {
                        updateSetting('notifications.memoEmails', newVal);
                    });

                    watch(() => settings.value.notifications.profileUpdates, (newVal) => {
                        updateSetting('notifications.profileUpdates', newVal);
                    });

                    // Lifecycle
                    onMounted(async () => {
                        // Check if password was changed - redirect to login if so
                        if (sessionStorage.getItem('passwordChanged') === 'true') {
                            sessionStorage.removeItem('passwordChanged');
                            window.location.href = '/auth/logout';
                            return;
                        }

                        lucide.createIcons();
                        // Hydrate settings (darkMode, notifications, session timeout) from backend
                        try {
                            const res = await fetch('/api/settings', { credentials: 'same-origin' });
                            const data = await res.json();
                            if (res.ok && data.success && data.settings) {
                                settings.value.darkMode = !!data.settings.darkMode;
                                settings.value.twoFactorEnabled = !!data.settings.twoFactorEnabled;
                                if (data.settings.sessionTimeoutMinutes) {
                                    settings.value.sessionTimeout = data.settings.sessionTimeoutMinutes;
                                }
                                if (data.settings.notifications) {
                                    settings.value.notifications = {
                                        memoEmails: !!data.settings.notifications.memoEmails,
                                        profileUpdates: !!data.settings.notifications.profileUpdates
                                    };
                                }
                            }
                        } catch (e) {
                            // Non-critical: keep defaults if settings can't be loaded
                            console.error('Error hydrating settings:', e);
                        }
                    });

                    return {
                        // State
                        currentUser,
                        loading,
                        saving,
                        passwordForm,
                        passwordFeedback,
                        settings,
                        // Computed
                        passwordsMatch,
                        isPasswordValid,
                        // Methods
                        updatePassword,
                        updateSessionTimeout
                    };
                }
            });

            app.mount('#app');
        });
    </script>

    <!-- Vue App Container -->
    <div id="app" class="dashboard-container">
        <%- include('../../components/nav'); %>

        <main class="main-content">
            <%- include('../../components/admintopbar'); %>

            <section class="settings-section">
                <div class="settings-header">
                    <h1>Workspace Settings</h1>
                    <p>Manage your account security and workspace preferences.</p>
                </div>

                <div class="settings-grid">
                    <!-- Change Password Card -->
                    <div class="settings-card">
                        <h3>Change Password</h3>
                        <p>Update your password regularly to keep your account secure.</p>
                        <form @submit.prevent="updatePassword" class="settings-form">
                            <div>
                                <label for="currentPassword">Current Password</label>
                                <input
                                    type="password"
                                    id="currentPassword"
                                    v-model="passwordForm.currentPassword"
                                    autocomplete="current-password"
                                    required>
                            </div>
                            <div>
                                <label for="newPassword">New Password</label>
                                <input
                                    type="password"
                                    id="newPassword"
                                    v-model="passwordForm.newPassword"
                                    autocomplete="new-password"
                                    required>
                                <password-strength :password="passwordForm.newPassword"></password-strength>
                            </div>
                            <div>
                                <label for="confirmPassword">Confirm New Password</label>
                                <input
                                    type="password"
                                    id="confirmPassword"
                                    v-model="passwordForm.confirmPassword"
                                    autocomplete="new-password"
                                    required>
                                <div v-if="passwordForm.confirmPassword && !passwordsMatch" class="password-mismatch">
                                    Passwords do not match
                                </div>
                            </div>
                            <div class="settings-actions">
                                <button
                                    type="submit"
                                    class="settings-btn primary"
                                    :disabled="loading || !isPasswordValid">
                                    Update Password
                                </button>
                            </div>
                        </form>
                    </div>

                    <!-- Session Timeout Card -->
                    <div class="settings-card">
                        <h3>Session Timeout</h3>
                        <p>Choose how long to keep sessions active while idle.</p>
                        <div class="settings-form">
                            <div>
                                <label for="sessionTimeoutSelect">Auto logout after</label>
                                <select
                                    id="sessionTimeoutSelect"
                                    v-model="settings.sessionTimeout"
                                    @change="updateSessionTimeout"
                                    :disabled="saving.sessionTimeout">
                                    <option value="1">1 minute</option>
                                    <option value="5">5 minutes</option>
                                    <option value="10">10 minutes</option>
                                    <option value="15">15 minutes</option>
                                    <option value="30">30 minutes</option>
                                    <option value="60">1 hour</option>
                                    <option value="1440">24 hours</option>
                                </select>
                            </div>
                            <div class="settings-feedback" id="sessionFeedback" role="status"></div>
                        </div>
                    </div>

                    <!-- Notifications Card -->
                    <div class="settings-card">
                        <h3>Notifications</h3>
                        <p>Stay informed about activity that matters.</p>
                        <div class="preferences-grid">
                            <setting-toggle
                                title="New Memo Emails"
                                description="Email me whenever new memos are created."
                                v-model="settings.notifications.memoEmails"
                                setting-key="notifications.memoEmails"
                                :loading="saving['notifications.memoEmails']">
                            </setting-toggle>
                            <setting-toggle
                                title="Profile Updates"
                                description="Notify me when users update their details."
                                v-model="settings.notifications.profileUpdates"
                                setting-key="notifications.profileUpdates"
                                :loading="saving['notifications.profileUpdates']">
                            </setting-toggle>
                        </div>
                        <div class="settings-feedback" id="notificationFeedback" role="status"></div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

        // Add CSS for password strength and loading states
        const style = document.createElement('style');
        style.textContent = `
            .password-strength {
                margin-top: 0.5rem;
                font-size: 0.875rem;
            }

            .strength-bar {
                width: 100%;
                height: 4px;
                background: #e5e7eb;
                border-radius: 2px;
                overflow: hidden;
                margin-bottom: 0.25rem;
            }

            .strength-fill {
                height: 100%;
                transition: width 0.3s ease;
            }

            .strength-fill.very-weak { background: #ef4444; }
            .strength-fill.weak { background: #f59e0b; }
            .strength-fill.fair { background: #eab308; }
            .strength-fill.good { background: #84cc16; }
            .strength-fill.strong { background: #22c55e; }
            .strength-fill.very-strong { background: #15803d; }

            .strength-text {
                color: #6b7280;
                font-size: 0.75rem;
            }

            .password-mismatch {
                color: #ef4444;
                font-size: 0.875rem;
                margin-top: 0.25rem;
            }

            .switch input:disabled + .slider.loading {
                opacity: 0.6;
                cursor: not-allowed;
            }

            .settings-btn:disabled {
                opacity: 0.6;
                cursor: not-allowed;
            }

            .settings-feedback.success {
                color: #059669;
                background: #ecfdf5;
                border: 1px solid #a7f3d0;
            }

            .settings-feedback.error {
                color: #dc2626;
                background: #fef2f2;
                border: 1px solid #fecaca;
            }

            /* Improved override for success ring - keep it perfectly circular without layout distortion */
            div:where(.swal2-icon).swal2-success .swal2-success-ring {
                /* Remove border (which changes box size) and use a shadow-based ring instead */
                border: 0 !important;
                /* Ring with box-shadow (doesn't change element metrics) + soft outer glow */
                box-shadow: 0 0 0 3px rgba(16,185,129, 0.28), 0 10px 30px rgba(16,185,129, 0.12);
                /* Keep the element perfectly circular */
                border-radius: 50% !important;
                /* Disable any transform/animation that could scale or distort visuals */
                transform: none !important;
                animation: none !important;
                /* Ensure the ring is drawn within the circle and doesn't hide overflowing parts */
                box-sizing: border-box;
                overflow: visible;
                pointer-events: none; /* avoid accidental interactions */
            }

            /* Optional: slightly different ring in dark mode */
            body.dark-mode div:where(.swal2-icon).swal2-success .swal2-success-ring {
                box-shadow: 0 0 0 3px rgba(52,211,153, 0.26), 0 10px 30px rgba(16,24,40, 0.12);
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
