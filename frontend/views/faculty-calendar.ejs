<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Calendar | Memofy</title>
	<link rel="icon" type="image/png" href="/images/memofy-logo.png">
	<link rel="stylesheet" href="/css/secretary-dashboard.css">
	<link rel="stylesheet" href="/css/fal-topbar.css">
	<link rel="stylesheet" href="/css/fal-nav.css">
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<!-- FullCalendar removed - using custom calendar -->
	<link rel="stylesheet" href="/css/calendar.css">
	<link rel="stylesheet" href="/css/custom-calendar.css">

	<!-- Google Analytics Tracking -->
	<%- include('google-analytics', { propertyId: typeof gaPropertyId !== 'undefined' ? gaPropertyId : null }); %>

	<!-- SweetAlert2 -->
	<%- include('../components/sweetalert2'); %>

	<!-- Vue 3 CDN -->
	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>
	<div id="app">
		<div class="dashboard-container">
			<%- include('../components/fal-nav'); %>
			<main class="main-content">
				<%- include('../components/fal-topbar') %>

				<div class="calendar-page">
					<aside class="calendar-sidebar">
						<div class="sidebar-section">
							<div class="mini-cal-header">
								<h3>{{ miniCalendarTitle }}</h3>
								<div class="mini-cal-nav">
									<button @click="prevMiniMonth" class="btn-icon" aria-label="Prev">&#8249;</button>
									<button @click="nextMiniMonth" class="btn-icon" aria-label="Next">&#8250;</button>
								</div>
							</div>
							<div class="mini-calendar">
								<div class="mini-cal-header-row">
									<span v-for="day in dayHeaders" :key="day" class="mini-cal-day-header">{{ day }}</span>
								</div>
								<div class="mini-cal-days">
									<div
										v-for="date in miniCalendarDates"
										:key="date.date"
										class="mini-cal-day"
										:class="{
											'mini-cal-day-other': !date.isCurrentMonth,
											'mini-cal-day-today': date.isToday,
											'mini-cal-day-selected': date.isSelected,
											'mini-cal-day-has-events': date.hasEvents
										}"
										@click="selectMiniDate(date)"
									>
										{{ date.day }}
										<div v-if="date.hasEvents" class="mini-cal-event-dot"></div>
									</div>
								</div>
							</div>
						</div>
						<div class="sidebar-section">
							<h3>My Calendars</h3>
							<label><input type="checkbox" v-model="calendarFilters.all" @change="updateCalendarFilters"> All</label><br/>
							<label><input type="checkbox" v-model="calendarFilters.mine" @change="updateCalendarFilters"> My Events</label><br/>
							<label><input type="checkbox" v-model="calendarFilters.department" @change="updateCalendarFilters"> Department</label>
						</div>
						<div class="sidebar-section">
							<h3>Categories</h3>
							<div><span class="category-dot cat-today"></span>Today</div>
							<div><span class="category-dot cat-urgent"></span>Urgent</div>
							<div><span class="category-dot cat-standard"></span>Standard</div>
						</div>
					</aside>

					<section class="calendar-main">
						<div id="calendar"></div>
					</section>
				</div>
			</main>
		</div>

	</div>

	<script>
		// Pass server-side data to Vue and calendar scripts
		<% const hasCalendarToken = !!(user.calendarAccessToken || user.calendarRefreshToken); %>
		window.calendarConnected = <%- JSON.stringify(hasCalendarToken) %>;
		window.currentUser = <%- JSON.stringify({
			id: user._id,
			email: user.email || '',
			firstName: user.firstName || '',
			lastName: user.lastName || '',
			role: user.role || 'faculty',
			department: user.department || '',
			profilePicture: user.profilePicture || ''
		}) %>;
		// Mark as view-only for faculty
		window.calendarViewOnly = true;
	</script>

	<script src="/js/lucide.min.js"></script>
	<!-- FullCalendar removed - using custom calendar -->
	<script src="/js/image-error-handler.js"></script>
	<script src="/js/custom-calendar.js"></script>
	<script src="/js/calendar-custom.js"></script>
	<script>
		const { createApp } = Vue;

		createApp({
			data() {
				return {
					// User data - initialized from window.currentUser
					user: window.currentUser ? {
						profilePicture: window.currentUser.profilePicture || '',
						firstName: window.currentUser.firstName || '',
						lastName: window.currentUser.lastName || '',
						email: window.currentUser.email || '',
						name: (window.currentUser.firstName || '') + ' ' + (window.currentUser.lastName || '')
					} : {
						profilePicture: '',
						firstName: '',
						lastName: '',
						email: '',
						name: ''
					},

					// Mini calendar
					currentMiniDate: new Date(),
					selectedDate: new Date(),

					// Calendar filters
					calendarFilters: {
						all: true,
						mine: true,
						department: true
					},

					// Events data (you can populate this from your API)
					events: [],

					// Day headers for mini calendar
					dayHeaders: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],

					// Refresh interval for real-time updates
					refreshInterval: null
				}
			},
			computed: {
				userDisplayName() {
					if (this.user.firstName && this.user.lastName) {
						return this.user.firstName + ' ' + this.user.lastName;
					}
					return this.user.name || 'User';
				},

				miniCalendarTitle() {
					return this.currentMiniDate.toLocaleString('default', { month: 'long', year: 'numeric' });
				},

				miniCalendarDates() {
					const year = this.currentMiniDate.getFullYear();
					const month = this.currentMiniDate.getMonth();

					// First day of the month
					const firstDay = new Date(year, month, 1);
					// Last day of the month
					const lastDay = new Date(year, month + 1, 0);
					// First day of the calendar grid (may be from previous month)
					const startDay = new Date(firstDay);
					startDay.setDate(startDay.getDate() - firstDay.getDay());

					const dates = [];
					const today = new Date();
					today.setHours(0, 0, 0, 0);

					const selectedDate = new Date(this.selectedDate);
					selectedDate.setHours(0, 0, 0, 0);

					// Generate 42 days (6 weeks)
					for (let i = 0; i < 42; i++) {
						const currentDate = new Date(startDay);
						currentDate.setDate(startDay.getDate() + i);

						const dateObj = {
							date: currentDate.toISOString().split('T')[0],
							day: currentDate.getDate(),
							isCurrentMonth: currentDate.getMonth() === month,
							isToday: currentDate.toDateString() === today.toDateString(),
							isSelected: currentDate.toDateString() === selectedDate.toDateString(),
							hasEvents: this.hasEventsOnDate(currentDate)
						};

						dates.push(dateObj);
					}

					return dates;
				}
			},
			mounted() {
				this.initializeCalendar();
				this.refreshLucideIcons();

				// Set up real-time refresh for events (every 30 seconds)
				this.refreshInterval = setInterval(() => {
					this.fetchEvents();
					// Also refresh main calendar if available
					if (window.customCalendar && typeof window.customCalendar.loadEvents === 'function') {
						window.customCalendar.loadEvents();
					}
				}, 30000); // Refresh every 30 seconds
			},

			beforeUnmount() {
				// Clean up interval when component is destroyed
				if (this.refreshInterval) {
					clearInterval(this.refreshInterval);
				}
			},
			methods: {
				async initializeCalendar() {
					// Initialize with server-side data
					if (window.currentUser) {
						this.user = { ...this.user, ...window.currentUser };
					}

					// Fetch events from backend API for mini calendar indicators
					await this.fetchEvents();

					// Your existing calendar initialization code can go here
					// The main calendar will be handled by your existing custom-calendar.js
				},

				async fetchEvents() {
					try {
						// Get wider date range to include adjacent months (for mini calendar display)
						// Mini calendar shows dates from previous and next months, so we need to fetch those too
						const year = this.currentMiniDate.getFullYear();
						const month = this.currentMiniDate.getMonth();

						// Start from first day of previous month, end at last day of next month
						const start = new Date(year, month - 1, 1);
						const end = new Date(year, month + 2, 0); // Last day of next month

						const response = await fetch(`/api/calendar/events?start=${start.toISOString()}&end=${end.toISOString()}`, {
							credentials: 'same-origin'
						});

						if (response.ok) {
							const data = await response.json();
							// API returns array directly, not wrapped in events property
							this.events = Array.isArray(data) ? data : (data.events || []);
							console.log(`ðŸ“… Fetched ${this.events.length} events for mini calendar`);
						} else {
							console.warn('Failed to fetch events, using empty array');
							this.events = [];
						}
					} catch (error) {
						console.error('Error fetching calendar events:', error);
						this.events = [];
					}
				},

				refreshLucideIcons() {
					if (typeof lucide !== 'undefined') {
						lucide.createIcons();
					}
				},

				async prevMiniMonth() {
					this.currentMiniDate = new Date(
						this.currentMiniDate.getFullYear(),
						this.currentMiniDate.getMonth() - 1,
						1
					);
					// Refetch events for the new month
					await this.fetchEvents();
				},

				async nextMiniMonth() {
					this.currentMiniDate = new Date(
						this.currentMiniDate.getFullYear(),
						this.currentMiniDate.getMonth() + 1,
						1
					);
					// Refetch events for the new month
					await this.fetchEvents();
				},

				selectMiniDate(date) {
					// Parse date string as local date to avoid timezone issues
					// date.date is in format "YYYY-MM-DD", parse it as local date
					const dateParts = date.date.split('-');
					const localDate = new Date(
						parseInt(dateParts[0]),
						parseInt(dateParts[1]) - 1, // Month is 0-indexed
						parseInt(dateParts[2])
					);
					localDate.setHours(0, 0, 0, 0); // Set to midnight local time

					this.selectedDate = localDate;

					// If the selected date is from a different month, update the mini calendar
					if (!date.isCurrentMonth) {
						this.currentMiniDate = new Date(localDate);
						this.fetchEvents(); // Fetch events for the new month
					}

					// Trigger main calendar navigation (same as secretary calendar)
					if (window.customCalendar && typeof window.customCalendar.navigateToDate === 'function') {
						window.customCalendar.navigateToDate(localDate);
					}
				},

				hasEventsOnDate(date) {
					if (!this.events || this.events.length === 0) return false;

					const dateStr = date.toISOString().split('T')[0];
					return this.events.some(event => {
						if (!event.start) return false;
						const eventDate = new Date(event.start);
						const eventDateStr = eventDate.toISOString().split('T')[0];

						// Check if event is on this date or spans multiple days
						const eventEnd = event.end ? new Date(event.end) : eventDate;
						const eventEndStr = eventEnd.toISOString().split('T')[0];

						// Event is on this date if it starts on this date, ends on this date, or spans this date
						return eventDateStr === dateStr || eventEndStr === dateStr ||
						       (eventDateStr <= dateStr && eventEndStr >= dateStr);
					});
				},

				updateCalendarFilters() {
					// Update the main calendar filters
					if (window.customCalendar && typeof window.customCalendar.updateFilters === 'function') {
						window.customCalendar.updateFilters(this.calendarFilters);
					}
				},

				showAlert(title, message) {
					if (window.showAlertModal) {
						window.showAlertModal(message, title);
					} else if (window.Swal) {
						Swal.fire({
							icon: 'info',
							title: title || 'Notice',
							text: message || ''
						});
					} else {
						alert((title ? title + ': ' : '') + (message || ''));
					}
				},

				// Method to add events (for view-only mode, this might just show an alert)
				addEvent(date = null) {
					if (window.calendarViewOnly) {
						this.showAlert('View Only Mode', 'Faculty members have view-only access to the calendar. Please contact an administrator to make changes.');
						return;
					}
					// Open event creation modal using calendar-custom.js function
					if (window.openEventModal && typeof window.openEventModal === 'function') {
						window.openEventModal(date);
					} else if (window.openModal && typeof window.openModal === 'function') {
						window.openModal(date);
					} else {
						console.warn('Event creation modal function not available');
						this.showAlert('Error', 'Event creation is not available at this time.');
					}
				},

				// Method to edit events (for view-only mode)
				editEvent(event) {
					if (window.calendarViewOnly) {
						this.showAlert('View Only Mode', 'Faculty members have view-only access to the calendar. Please contact an administrator to make changes.');
						return;
					}
					// Open event editing modal using calendar-custom.js function
					if (!event || !event._id) {
						console.warn('Cannot edit event: event or event ID missing');
						this.showAlert('Error', 'Cannot edit event: Invalid event data.');
						return;
					}
					if (window.openEventModalForEdit && typeof window.openEventModalForEdit === 'function') {
						window.openEventModalForEdit(event._id);
					} else {
						console.warn('Event editing modal function not available');
						this.showAlert('Error', 'Event editing is not available at this time.');
					}
				}
			}
		}).mount('#app');
	</script>
</body>
</html>
