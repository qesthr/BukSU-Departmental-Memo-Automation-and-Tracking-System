<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Calendar | Memofy</title>
	<link rel="icon" type="image/png" href="/images/memofy-logo.png">
	<link rel="stylesheet" href="/css/secretary-dashboard.css">
	<link rel="stylesheet" href="/css/fal-topbar.css">
	<link rel="stylesheet" href="/css/fal-nav.css">
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<!-- FullCalendar removed - using custom calendar -->
	<link rel="stylesheet" href="/css/calendar.css">
	<link rel="stylesheet" href="/css/custom-calendar.css">

	<!-- Google Analytics Tracking -->
	<%- include('google-analytics', { propertyId: typeof gaPropertyId !== 'undefined' ? gaPropertyId : null }); %>

	<!-- SweetAlert2 -->
	<%- include('../components/sweetalert2'); %>

	<!-- Vue 3 CDN -->
	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>
	<div id="app">
		<div class="dashboard-container">
			<%- include('../components/fal-nav'); %>
			<main class="main-content">
				<%- include('../components/fal-topbar') %>

				<div class="calendar-page">
					<aside class="calendar-sidebar">
						<div class="sidebar-section">
							<div class="mini-cal-header">
								<h3>{{ miniCalendarTitle }}</h3>
								<div class="mini-cal-nav">
									<button @click="prevMiniMonth" class="btn-icon" aria-label="Prev">&#8249;</button>
									<button @click="nextMiniMonth" class="btn-icon" aria-label="Next">&#8250;</button>
								</div>
							</div>
							<div class="mini-calendar">
								<div class="mini-cal-days">
									<div v-for="day in dayHeaders" :key="day" class="mini-cal-day-header">{{ day }}</div>
								</div>
								<div class="mini-cal-dates">
									<div
										v-for="date in miniCalendarDates"
										:key="date.date"
										:class="[
											'mini-cal-date',
											{
												'mini-cal-other-month': !date.isCurrentMonth,
												'mini-cal-today': date.isToday,
												'mini-cal-selected': date.isSelected,
												'mini-cal-has-events': date.hasEvents
											}
										]"
										@click="selectMiniDate(date)"
									>
										{{ date.day }}
										<div v-if="date.hasEvents" class="mini-cal-event-dot"></div>
									</div>
								</div>
							</div>
						</div>
						<div class="sidebar-section">
							<h3>My Calendars</h3>
							<label><input type="checkbox" v-model="calendarFilters.all" @change="updateCalendarFilters"> All</label><br/>
							<label><input type="checkbox" v-model="calendarFilters.mine" @change="updateCalendarFilters"> My Events</label><br/>
							<label><input type="checkbox" v-model="calendarFilters.department" @change="updateCalendarFilters"> Department</label>
						</div>
						<div class="sidebar-section">
							<h3>Categories</h3>
							<div><span class="category-dot cat-today"></span>Today</div>
							<div><span class="category-dot cat-urgent"></span>Urgent</div>
							<div><span class="category-dot cat-standard"></span>Standard</div>
						</div>
						<div class="sidebar-section">
							<h3>Profile</h3>
							<div class="profile-card">
								<img :src="user.profilePicture || '/images/memofy-logo.png'" alt="Profile" />
								<div>
									<div style="font-weight:600">{{ userDisplayName }}</div>
									<div style="font-size:.85rem; color:#64748b">{{ user.email || 'email@example.com' }}</div>
								</div>
							</div>
						</div>
					</aside>

					<section class="calendar-main">
						<div id="calendar"></div>
					</section>
				</div>
			</main>
		</div>

		<!-- Custom Alert Modal (for view-only messages) -->
		<div v-if="showAlertModal" class="custom-modal">
			<div class="custom-modal-overlay"></div>
			<div class="custom-modal-content">
				<div class="custom-modal-header">
					<h3>{{ alertModalTitle }}</h3>
					<button class="custom-modal-close" @click="closeAlertModal">&times;</button>
				</div>
				<div class="custom-modal-body">
					<p>{{ alertModalMessage }}</p>
				</div>
				<div class="custom-modal-footer">
					<button class="custom-modal-btn custom-modal-btn-primary" @click="closeAlertModal">OK</button>
				</div>
			</div>
		</div>
	</div>

	<script>
		// Pass server-side data to Vue and calendar scripts
		<% const hasCalendarToken = !!(user.calendarAccessToken || user.calendarRefreshToken); %>
		window.calendarConnected = <%- JSON.stringify(hasCalendarToken) %>;
		window.currentUser = <%- JSON.stringify({
			id: user._id,
			email: user.email || '',
			firstName: user.firstName || '',
			lastName: user.lastName || '',
			role: user.role || 'faculty',
			department: user.department || '',
			profilePicture: user.profilePicture || ''
		}) %>;
		// Mark as view-only for faculty
		window.calendarViewOnly = true;
	</script>

	<script src="/js/lucide.min.js"></script>
	<!-- FullCalendar removed - using custom calendar -->
	<script src="/js/custom-calendar.js"></script>
	<script src="/js/calendar-custom.js"></script>
	<script>
		const { createApp } = Vue;

		createApp({
			data() {
				return {
					// User data - initialized from window.currentUser
					user: window.currentUser ? {
						profilePicture: window.currentUser.profilePicture || '',
						firstName: window.currentUser.firstName || '',
						lastName: window.currentUser.lastName || '',
						email: window.currentUser.email || '',
						name: (window.currentUser.firstName || '') + ' ' + (window.currentUser.lastName || '')
					} : {
						profilePicture: '',
						firstName: '',
						lastName: '',
						email: '',
						name: ''
					},

					// Mini calendar
					currentMiniDate: new Date(),
					selectedDate: new Date(),

					// Calendar filters
					calendarFilters: {
						all: true,
						mine: true,
						department: true
					},

					// Alert modal
					showAlertModal: false,
					alertModalTitle: 'Notice',
					alertModalMessage: '',

					// Events data (you can populate this from your API)
					events: [],

					// Day headers for mini calendar
					dayHeaders: ['S', 'M', 'T', 'W', 'T', 'F', 'S']
				}
			},
			computed: {
				userDisplayName() {
					if (this.user.firstName && this.user.lastName) {
						return this.user.firstName + ' ' + this.user.lastName;
					}
					return this.user.name || 'User';
				},

				miniCalendarTitle() {
					return this.currentMiniDate.toLocaleString('default', { month: 'long', year: 'numeric' });
				},

				miniCalendarDates() {
					const year = this.currentMiniDate.getFullYear();
					const month = this.currentMiniDate.getMonth();

					// First day of the month
					const firstDay = new Date(year, month, 1);
					// Last day of the month
					const lastDay = new Date(year, month + 1, 0);
					// First day of the calendar grid (may be from previous month)
					const startDay = new Date(firstDay);
					startDay.setDate(startDay.getDate() - firstDay.getDay());

					const dates = [];
					const today = new Date();
					today.setHours(0, 0, 0, 0);

					const selectedDate = new Date(this.selectedDate);
					selectedDate.setHours(0, 0, 0, 0);

					// Generate 42 days (6 weeks)
					for (let i = 0; i < 42; i++) {
						const currentDate = new Date(startDay);
						currentDate.setDate(startDay.getDate() + i);

						const dateObj = {
							date: currentDate.toISOString().split('T')[0],
							day: currentDate.getDate(),
							isCurrentMonth: currentDate.getMonth() === month,
							isToday: currentDate.toDateString() === today.toDateString(),
							isSelected: currentDate.toDateString() === selectedDate.toDateString(),
							hasEvents: this.hasEventsOnDate(currentDate)
						};

						dates.push(dateObj);
					}

					return dates;
				}
			},
			mounted() {
				this.initializeCalendar();
				this.refreshLucideIcons();
			},
			methods: {
				async initializeCalendar() {
					// Initialize with server-side data
					if (window.currentUser) {
						this.user = { ...this.user, ...window.currentUser };
					}

					// Fetch events from backend API for mini calendar indicators
					await this.fetchEvents();

					// Your existing calendar initialization code can go here
					// The main calendar will be handled by your existing custom-calendar.js
				},

				async fetchEvents() {
					try {
						// Get current month range for events
						const start = new Date(this.currentMiniDate.getFullYear(), this.currentMiniDate.getMonth(), 1);
						const end = new Date(this.currentMiniDate.getFullYear(), this.currentMiniDate.getMonth() + 1, 0);

						const response = await fetch(`/api/calendar/events?start=${start.toISOString()}&end=${end.toISOString()}`, {
							credentials: 'same-origin'
						});

						if (response.ok) {
							const data = await response.json();
							this.events = data.events || data || [];
						} else {
							console.warn('Failed to fetch events, using empty array');
							this.events = [];
						}
					} catch (error) {
						console.error('Error fetching calendar events:', error);
						this.events = [];
					}
				},

				refreshLucideIcons() {
					if (typeof lucide !== 'undefined') {
						lucide.createIcons();
					}
				},

				async prevMiniMonth() {
					this.currentMiniDate = new Date(
						this.currentMiniDate.getFullYear(),
						this.currentMiniDate.getMonth() - 1,
						1
					);
					// Refetch events for the new month
					await this.fetchEvents();
				},

				async nextMiniMonth() {
					this.currentMiniDate = new Date(
						this.currentMiniDate.getFullYear(),
						this.currentMiniDate.getMonth() + 1,
						1
					);
					// Refetch events for the new month
					await this.fetchEvents();
				},

				selectMiniDate(date) {
					this.selectedDate = new Date(date.date);

					// If the selected date is from a different month, update the mini calendar
					if (!date.isCurrentMonth) {
						this.currentMiniDate = new Date(this.selectedDate);
						this.fetchEvents(); // Fetch events for the new month
					}

					// Trigger main calendar navigation
					if (window.customCalendar && typeof window.customCalendar.navigateToDate === 'function') {
						window.customCalendar.navigateToDate(this.selectedDate);
					}
				},

				hasEventsOnDate(date) {
					if (!this.events || this.events.length === 0) return false;

					const dateStr = date.toISOString().split('T')[0];
					return this.events.some(event => {
						if (!event.start) return false;
						const eventDate = new Date(event.start).toISOString().split('T')[0];
						return eventDate === dateStr;
					});
				},

				updateCalendarFilters() {
					// Update the main calendar filters
					if (window.customCalendar && typeof window.customCalendar.updateFilters === 'function') {
						window.customCalendar.updateFilters(this.calendarFilters);
					}
				},

				showAlert(title, message) {
					this.alertModalTitle = title;
					this.alertModalMessage = message;
					this.showAlertModal = true;
				},

				closeAlertModal() {
					this.showAlertModal = false;
				},

				// Method to add events (for view-only mode, this might just show an alert)
				addEvent(date = null) {
					if (window.calendarViewOnly) {
						this.showAlert('View Only Mode', 'Faculty members have view-only access to the calendar. Please contact an administrator to make changes.');
						return;
					}
					// Open event creation modal using calendar-custom.js function
					if (window.openEventModal && typeof window.openEventModal === 'function') {
						window.openEventModal(date);
					} else if (window.openModal && typeof window.openModal === 'function') {
						window.openModal(date);
					} else {
						console.warn('Event creation modal function not available');
						this.showAlert('Error', 'Event creation is not available at this time.');
					}
				},

				// Method to edit events (for view-only mode)
				editEvent(event) {
					if (window.calendarViewOnly) {
						this.showAlert('View Only Mode', 'Faculty members have view-only access to the calendar. Please contact an administrator to make changes.');
						return;
					}
					// Open event editing modal using calendar-custom.js function
					if (!event || !event._id) {
						console.warn('Cannot edit event: event or event ID missing');
						this.showAlert('Error', 'Cannot edit event: Invalid event data.');
						return;
					}
					if (window.openEventModalForEdit && typeof window.openEventModalForEdit === 'function') {
						window.openEventModalForEdit(event._id);
					} else {
						console.warn('Event editing modal function not available');
						this.showAlert('Error', 'Event editing is not available at this time.');
					}
				}
			}
		}).mount('#app');
	</script>
</body>
</html>
