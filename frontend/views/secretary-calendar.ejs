<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Calendar | Memofy</title>
	<link rel="stylesheet" href="/css/admin-dash.css">
	<link rel="icon" type="image/png" href="/images/memofy-logo.png">
	<link rel="stylesheet" href="/css/secretary-dashboard.css">
	<link rel="stylesheet" href="/css/sec-topbar.css">
	<link rel="stylesheet" href="/css/sec-nav.css">
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="/css/calendar.css">
	<link rel="stylesheet" href="/css/custom-calendar.css">

	<!-- Google Analytics Tracking -->
	<%- include('google-analytics', { propertyId: typeof gaPropertyId !== 'undefined' ? gaPropertyId : null }); %>

	<!-- Vue.js CDN -->
	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

	<!-- SweetAlert2 -->
	<%- include('../components/sweetalert2'); %>
</head>
<body>
	<script>
		// Flag to let calendar-custom.js know this is the secretary Vue calendar,
		// so it should not override the Vue modal handlers.
		window.isSecretaryCalendar = true;
	</script>
	<div id="app" class="dashboard-container">
		<%- include('../components/sec-nav'); %>
		<main class="main-content">
			<%- include('../components/sec-topbar') %>

			<div class="calendar-page">
				<aside class="calendar-sidebar">
					<div class="sidebar-section">
						<div class="mini-cal-header">
							<h3>{{ miniCalendarTitle }}</h3>
							<div class="mini-cal-nav">
								<button @click="navigateMiniCalendar(-1)" class="btn-icon" aria-label="Prev">&#8249;</button>
								<button @click="navigateMiniCalendar(1)" class="btn-icon" aria-label="Next">&#8250;</button>
							</div>
						</div>
						<div class="mini-calendar">
							<div class="mini-cal-header-row">
								<span v-for="day in ['S', 'M', 'T', 'W', 'T', 'F', 'S']" :key="day" class="mini-cal-day-header">{{ day }}</span>
							</div>
							<div class="mini-cal-days">
								<div v-for="day in miniCalendarDays"
									:key="day.date"
									class="mini-cal-day"
									:class="{
										'mini-cal-day-other': !day.isCurrentMonth,
										'mini-cal-day-today': day.isToday,
										'mini-cal-day-selected': day.isSelected,
										'mini-cal-day-has-events': day.hasEvents
									}"
									@click="selectMiniCalendarDay(day)">
									{{ day.day }}
									<div v-if="day.hasEvents" class="mini-event-indicators">
										<span class="mini-event-dot" :style="{ backgroundColor: day.eventColor }" :title="day.eventCount + ' event(s)'"></span>
									</div>
								</div>
							</div>
						</div>
					</div>
					<div class="sidebar-section">
						<h3>My Calendars</h3>
						<label><input type="checkbox" v-model="filters.mine" @change="updateCalendarFilters"> My Events</label><br />
						<label><input type="checkbox" v-model="filters.department" @change="updateCalendarFilters"> Department</label>
					</div>
					<div class="sidebar-section">
						<h3>Categories</h3>
						<div><span class="category-dot cat-today"></span>Today</div>
						<div><span class="category-dot cat-urgent"></span>Urgent</div>
					</div>
				</aside>

				<section class="calendar-main">
					<div id="calendar"></div>
				</section>
			</div>

			<!-- Success Modal with Loading/Check Animation -->
			<div v-if="showSuccessModal" class="event-success-modal" :style="{ display: showSuccessModal ? 'flex' : 'none' }">
				<div class="event-success-modal-content">
					<div v-if="successLoading" class="success-loader">
						<div class="spinner"></div>
					</div>
					<div v-else class="success-check">
						<svg viewBox="0 0 52 52">
							<circle cx="26" cy="26" r="25" fill="none" class="check-circle"/>
							<path fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8" class="check-path"/>
						</svg>
					</div>
					<p class="success-message" v-text="successMessage"></p>
				</div>
			</div>

			<!-- Add/Edit Memo Modal (Vue-controlled, force visibility via inline style) -->
			<div
				id="memoModal"
				class="modal"
				:class="{ show: showMemoModal }"
				style="display: none;"
				:style="{ display: showMemoModal ? 'flex' : 'none' }"
			>
		<div class="modal-content">
			<div class="modal-header">
				<h2>{{ memoModalTitle }}</h2>
				<button class="close-modal" @click="closeMemoModal" style="border:none; background:none; font-size:1.5rem; cursor:pointer">&times;</button>
			</div>
			<div class="modal-body">
				<!-- Read-Only View (for Recipients) -->
				<div v-if="isReadOnlyView" class="read-only-view">
					<div class="form-group">
						<strong>{{ selectedEvent.title || 'No Title' }}</strong>
					</div>
					<div class="form-group" style="display:grid; grid-template-columns: 1fr 1fr; gap:.5rem;">
						<div>
							<label>Category</label>
							<div>{{ getCategoryLabel(selectedEvent.category) }}</div>
						</div>
						<div>
							<label>Date</label>
							<div>{{ formatDisplayDate(selectedEvent.date) }}</div>
						</div>
					</div>
					<div class="form-group" style="display:grid; grid-template-columns: 1fr 1fr; gap:.5rem;">
						<div>
							<label>Start Time</label>
							<div>{{ selectedEvent.startTime || 'Not set' }}</div>
						</div>
						<div>
							<label>End Time</label>
							<div>{{ selectedEvent.endTime || 'Not set' }}</div>
						</div>
					</div>
					<div class="form-group">
						<label>Participants / Recipients</label>
						<div>{{ formatParticipantsDisplay(selectedEvent.participants) }}</div>
					</div>
					<div class="form-group">
						<label>Description / Notes</label>
						<div class="read-only-description">{{ selectedEvent.description || 'No description' }}</div>
					</div>
					<div class="form-actions">
						<button type="button" class="btn-primary" @click="closeMemoModal" style="margin-left:auto">OK</button>
					</div>
				</div>

				<!-- Editable Form (for Creators) -->
				<form v-else @submit.prevent="saveEvent">
					<input type="hidden" v-model="editingEvent.id" />
					<input type="hidden" v-model="editingEvent.source" />
					<div class="form-group">
						<label for="memoTitle">Title of Memo</label>
						<input type="text" id="memoTitle" v-model="editingEvent.title" required />
					</div>
					<div class="form-group" style="display:grid; grid-template-columns: 1fr 1fr; gap:.5rem;">
						<div>
							<label for="memoDate">Start Date</label>
							<input type="date" id="memoDate" v-model="editingEvent.date" required />
						</div>
						<div>
							<label for="memoEndDate">End Date</label>
							<input type="date" id="memoEndDate" v-model="editingEvent.endDate" />
						</div>
					</div>
					<div class="form-group" style="display:grid; grid-template-columns: 1fr 1fr; gap:.5rem;">
						<div>
							<label for="memoStart">Start Time</label>
							<input type="time" id="memoStart" v-model="editingEvent.startTime" required />
						</div>
						<div>
							<label for="memoEnd">End Time</label>
							<input type="time" id="memoEnd" v-model="editingEvent.endTime" required />
						</div>
					</div>
					<div class="form-group">
						<div class="participant-input-container">
							<label class="participant-label">Participants / Recipients:</label>
							<div class="participant-input-wrapper">
								<div class="participant-chips-wrapper">
									<span v-for="participant in editingEvent.participants"
										:key="participant.id || participant.email"
										class="participant-chip">
										{{ participant.name || participant.email }}
										<button type="button" @click="removeParticipant(participant)" class="chip-remove">&times;</button>
									</span>
								</div>
								<input type="text"
									v-model="participantSearch"
									@input="searchParticipants"
									@keydown.enter.prevent="addParticipantFromSearch"
									class="participant-input"
									placeholder="Type name or email to search recipients..."
									autocomplete="off" />
								<ul v-if="participantSuggestions.length > 0" class="email-suggestions">
									<li v-for="suggestion in participantSuggestions"
										:key="suggestion.id || suggestion.email"
										@click="addParticipant(suggestion)">
										{{ suggestion.name || suggestion.email }}
									</li>
								</ul>
							</div>
						</div>
						<div v-if="currentUser.department" style="margin-top:.5rem; display:flex; align-items:center; gap:.5rem; padding:.25rem .5rem; border:1px solid #e5e7eb; border-radius:4px; background:#f9fafb;">
							<input type="checkbox" id="sendToDept" v-model="sendToDepartment" />
							<label for="sendToDept" style="font-size:0.9rem; color:#4b5563;">
								Send to my department ({{ currentUser.department }})
							</label>
						</div>
					</div>
					<div class="form-group">
						<label for="memoDesc">Description / Notes</label>
						<textarea id="memoDesc" v-model="editingEvent.description" rows="4"></textarea>
					</div>

					<div class="form-actions">
						<div style="display:flex; align-items:center; gap:.5rem;">
							<label for="memoCategory" style="font-size:0.9rem; color:#4b5563;">Category</label>
							<select id="memoCategory" v-model="editingEvent.category" style="min-width: 180px;">
								<option value="standard">üü¢ Standard</option>
								<option value="urgent">üî¥ Urgent</option>
								<option value="high">üü† High Priority</option>
								<option value="meeting">üü£ Meeting</option>
								<option value="deadline">‚è∞ Deadline</option>
								<option value="reminder">üîî Reminder</option>
								<option value="low">üîµ Low Priority</option>
							</select>
						</div>
						<div style="display:flex; align-items:center; gap:.5rem; margin-left:auto;">
							<button type="button" class="btn-secondary" @click="closeMemoModal">Cancel</button>
							<button v-if="isEditing" type="button" class="btn-secondary" @click="archiveEvent">Archive</button>
							<button v-if="isEditing" type="button" class="btn-secondary" @click="deleteEvent">Delete</button>
							<button type="submit" class="btn-primary">{{ isEditing ? 'Update' : 'Add' }}</button>
						</div>
					</div>
				</form>
			</div>
		</div>
	</div>

	<!-- Custom Confirmation Modal -->
	<div v-if="showConfirmModal" class="custom-modal" :style="{ display: showConfirmModal ? 'flex' : 'none' }">
		<div class="custom-modal-overlay"></div>
		<div class="custom-modal-content">
			<div class="custom-modal-header">
				<h3 v-text="confirmModalTitle"></h3>
				<button class="custom-modal-close" @click="closeConfirmModal">&times;</button>
			</div>
			<div class="custom-modal-body">
				<p v-text="confirmModalMessage"></p>
			</div>
			<div class="custom-modal-footer">
				<button class="custom-modal-btn custom-modal-btn-secondary" @click="closeConfirmModal">Cancel</button>
				<button class="custom-modal-btn custom-modal-btn-primary" @click="confirmAction">OK</button>
			</div>
		</div>
	</div>

	<!-- Custom Alert Modal -->
	<div v-if="showAlertModal" class="custom-modal" :style="{ display: showAlertModal ? 'flex' : 'none' }">
		<div class="custom-modal-overlay"></div>
		<div class="custom-modal-content">
			<div class="custom-modal-header">
				<h3 v-text="alertModalTitle"></h3>
				<button class="custom-modal-close" @click="closeAlertModal">&times;</button>
			</div>
			<div class="custom-modal-body">
				<p v-text="alertModalMessage"></p>
			</div>
			<div class="custom-modal-footer">
				<button class="custom-modal-btn custom-modal-btn-primary" @click="closeAlertModal">OK</button>
			</div>
		</div>
	</div>

	<!-- Set global variables before scripts load -->
	<script>
		// Set global calendar connection status for calendar scripts
		window.calendarConnected = <%= (user.calendarAccessToken || user.calendarRefreshToken) ? 'true' : 'false' %>;
		window.currentUser = {
			id: '<%= user._id %>',
			email: '<%= user.email %>',
			firstName: '<%= user.firstName || "" %>',
			lastName: '<%= user.lastName || "" %>',
			role: '<%= user.role %>',
			department: '<%= user.department || "" %>'
		};
	</script>
	<script src="/js/lucide.min.js"></script>
	<script src="/js/custom-calendar.js"></script>
	<script>
		const { createApp } = Vue;

		// Bridge function to connect custom calendar with Vue calendar
		// This must be defined before the Vue app mounts
		function initCustomCalendar(vueApp) {
			function openSecretaryCalendarModal(dateOrEvent = null) {
				console.log('[Calendar] openSecretaryCalendarModal called with:', dateOrEvent);
				if (!vueApp || typeof vueApp.openMemoModal !== 'function') { return; }

				// If dateOrEvent is a Date, create a new event with that date/time (CREATE MODE)
				if (dateOrEvent instanceof Date) {
					const hours = dateOrEvent.getHours();
					const minutes = dateOrEvent.getMinutes();
					const timeStr = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
					const endTime = new Date(dateOrEvent);
					endTime.setHours(hours + 1, minutes, 0, 0);
					const endTimeStr = `${String(endTime.getHours()).padStart(2, '0')}:${String(endTime.getMinutes()).padStart(2, '0')}`;

					const dateStr = vueApp.formatDateLocal(dateOrEvent);

					const newEvent = {
						id: '',
						source: '',
						title: '',
						date: dateStr,
						endDate: dateStr,
						category: 'standard',
						startTime: timeStr,
						endTime: endTimeStr,
						description: '',
						participants: []
					};
					vueApp.openMemoModal(newEvent, false);
					return;
				}

				// If dateOrEvent is an object from calendar-custom.js (EDIT MODE)
				if (dateOrEvent && typeof dateOrEvent === 'object') {
					const isReadOnly = !!dateOrEvent.__readOnly;
					// Clone event and remove internal flags
					const eventData = { ...dateOrEvent };
					delete eventData.__readOnly;

					vueApp.openMemoModal(eventData, isReadOnly);
					return;
				}

				// Fallback: open empty modal
				console.log('[Calendar] openSecretaryCalendarModal -> opening empty modal (new event)');
				vueApp.openMemoModal(null, false);
			}

			// Expose globally so other scripts can call it reliably
			window.openSecretaryCalendarModal = openSecretaryCalendarModal;

			// Maintain backwards compatibility for scripts that call window.openModal directly
			window.openModal = openSecretaryCalendarModal;

			// Also expose it as openEventModal for compatibility
			window.openEventModal = window.openModal;
		}

		// Initialize Vue app
		document.addEventListener('DOMContentLoaded', function() {
			const app = createApp({
				data() {
					return {
						// User data from EJS (Joenil please fetch and integrate data here)
						currentUser: {
							id: '<%= user._id %>',
							email: '<%= user.email %>',
							firstName: '<%= user.firstName || "" %>',
							lastName: '<%= user.lastName || "" %>',
							role: '<%= user.role %>',
							department: '<%= user.department || "" %>',
							profilePicture: '<%= user.profilePicture || "/images/memofy-logo.png" %>',
							displayName: '<%= (user.firstName && user.lastName) ? user.firstName + " " + user.lastName : user.name || "User" %>'
						},
						calendarConnected: <%= (user.calendarAccessToken || user.calendarRefreshToken) ? 'true' : 'false' %>,

						// Calendar state
						currentDate: new Date(),
						miniCalendarDays: [],
						events: [], // Store events for mini calendar indicators

						// Filters
						filters: {
							mine: true,
							department: true
						},

						// Modal states
						showMemoModal: false,
						showSuccessModal: false,
						showConfirmModal: false,
						showAlertModal: false,

						// Success modal
						successLoading: false,
						successMessage: '',

						// Memo/Event editing
						editingEvent: {
							id: '',
							source: '',
							title: '',
							date: this.getTodayDate(),
							endDate: this.getTodayDate(),
							category: 'standard',
							startTime: '09:00',
							endTime: '10:00',
							description: '',
							participants: []
						},
						selectedEvent: null,
						isEditing: false,
						isReadOnlyView: false,

						// Participant management
						participantSearch: '',
						participantSuggestions: [],
						sendToDepartment: true,

						// Confirmation modal
						confirmModalTitle: '',
						confirmModalMessage: '',
						confirmCallback: null,

						// Alert modal
						alertModalTitle: '',
						alertModalMessage: ''
					}
				},
				computed: {
					miniCalendarTitle() {
						return this.currentDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
					},
					memoModalTitle() {
						if (this.isReadOnlyView) return 'Event Details';
						return this.isEditing ? 'Edit Event' : 'Add Event';
					}
				},
				mounted() {
					this.generateMiniCalendar();
					this.initializeCustomCalendar();
					this.fetchEvents(); // Load events for mini calendar indicators

					// Initialize Lucide icons
					if (typeof lucide !== 'undefined') {
						lucide.createIcons();
					}
				},
				methods: {
					// Helper function to format date as YYYY-MM-DD in local time (not UTC)
					formatDateLocal(date) {
						const year = date.getFullYear();
						const month = String(date.getMonth() + 1).padStart(2, '0');
						const day = String(date.getDate()).padStart(2, '0');
						return `${year}-${month}-${day}`;
					},

					// Calendar methods
					async fetchEvents() {
						try {
							// Get wider date range to include adjacent months (for mini calendar display)
							const year = this.currentDate.getFullYear();
							const month = this.currentDate.getMonth();

							// Start from first day of previous month, end at last day of next month
							const start = new Date(year, month - 1, 1);
							const end = new Date(year, month + 2, 0); // Last day of next month

							// Format dates for API
							const formatForAPI = (date) => {
								const d = new Date(date);
								const year = d.getFullYear();
								const month = String(d.getMonth() + 1).padStart(2, '0');
								const day = String(d.getDate()).padStart(2, '0');
								const hours = String(d.getHours()).padStart(2, '0');
								const minutes = String(d.getMinutes()).padStart(2, '0');
								const seconds = String(d.getSeconds()).padStart(2, '0');
								return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+08:00`;
							};

							const startStr = formatForAPI(start);
							const endStr = formatForAPI(end);

							let allEvents = [];

							// Fetch database events
							const qs = new URLSearchParams({ start: startStr, end: endStr });
							const res = await fetch(`/api/calendar/events?${qs.toString()}`, {
								credentials: 'same-origin'
							});

							if (res.ok) {
								const data = await res.json();
								const dbEvents = data.map(e => ({
									id: e._id,
									start: e.start,
									end: e.end,
									category: e.category || 'standard',
									title: e.title || ''
								}));
								allEvents = [...allEvents, ...dbEvents];
							}

							// Fetch Google Calendar events and public holidays
							// Note: /calendar/events returns public holidays even without Google Calendar connection
							try {
								const formatForGoogleAPI = (dateStr) => {
									if (!dateStr) return dateStr;
									if (/[+-]\d{2}:\d{2}$/.test(dateStr) || dateStr.endsWith('Z')) return dateStr;
									if (dateStr.includes('T')) return `${dateStr}+08:00`;
									return `${dateStr}T00:00:00+08:00`;
								};

								const timeMin = formatForGoogleAPI(startStr);
								const timeMax = formatForGoogleAPI(endStr);

								const r2 = await fetch(`/calendar/events?timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}`, {
									credentials: 'same-origin'
								});

								if (r2.ok) {
									const gItems = await r2.json();
									const googleEvents = gItems.map(ev => {
										const isGoogleAllDay = ev.start.date ? true : false;
										const isHoliday = ev.isHoliday === true;
										let eventStart = isGoogleAllDay ? ev.start.date : ev.start.dateTime;
										let eventEnd = isGoogleAllDay ? ev.end.date : ev.end.dateTime;

										// Convert date strings to Date objects for proper comparison
										if (isGoogleAllDay) {
											if (eventStart && typeof eventStart === 'string') {
												const [y, m, d] = eventStart.split('-').map(Number);
												eventStart = new Date(y, m - 1, d, 0, 0, 0, 0);
											}
											if (eventEnd && typeof eventEnd === 'string') {
												const endDate = new Date(eventEnd);
												endDate.setDate(endDate.getDate() - 1);
												const [y, m, d] = endDate.toISOString().split('T')[0].split('-').map(Number);
												eventEnd = new Date(y, m - 1, d, 23, 59, 59, 999);
											}
										} else {
											eventStart = new Date(eventStart);
											eventEnd = new Date(eventEnd);
										}

										return {
											id: 'gcal_' + ev.id,
											start: eventStart,
											end: eventEnd,
											category: isHoliday ? 'holiday' : 'standard',
											title: isHoliday ? `üéâ ${ev.summary || '(no title)'}` : (ev.summary || '(no title)')
										};
									});
									allEvents = [...allEvents, ...googleEvents];
								}
							} catch (err) {
								console.warn('Error fetching Google Calendar events and holidays:', err);
							}

							this.events = allEvents;
							// Regenerate mini calendar to update event indicators
							this.generateMiniCalendar();
						} catch (error) {
							console.error('Error fetching calendar events:', error);
							this.events = [];
						}
					},

					getEventsForDate(dateStr) {
						if (!this.events || this.events.length === 0) return [];
						return this.events.filter(event => {
							let eventStart, eventEnd;

							if (typeof event.start === 'string') {
								if (event.start.includes('T')) {
									eventStart = new Date(event.start);
								} else {
									const [year, month, day] = event.start.split('-').map(Number);
									eventStart = new Date(year, month - 1, day, 0, 0, 0, 0);
								}
							} else {
								eventStart = new Date(event.start);
							}

							if (typeof event.end === 'string') {
								if (event.end.includes('T')) {
									eventEnd = new Date(event.end);
								} else {
									const [year, month, day] = event.end.split('-').map(Number);
									eventEnd = new Date(year, month - 1, day, 23, 59, 59, 999);
								}
							} else {
								eventEnd = new Date(event.end);
							}

							const eventStartStr = this.formatDateLocal(eventStart);
							const eventEndStr = this.formatDateLocal(eventEnd);

							if (eventStartStr === dateStr) return true;
							if (dateStr >= eventStartStr && dateStr <= eventEndStr) return true;
							return false;
						});
					},

					getCategoryColor(category) {
						switch (category) {
							case 'urgent': return '#fee2e2';
							case 'high': return '#fed7aa';
							case 'meeting': return '#e9d5ff';
							case 'deadline': return '#fecaca';
							case 'reminder': return '#fef3c7';
							case 'low': return '#dbeafe';
							case 'holiday': return '#FEF3C7';
							case 'standard':
							default: return '#d1fae5';
						}
					},

					getHighestPriorityCategory(events) {
						if (events.some(e => e.category === 'urgent')) return 'urgent';
						if (events.some(e => e.category === 'high')) return 'high';
						if (events.some(e => e.category === 'holiday')) return 'holiday';
						if (events.some(e => e.category === 'meeting')) return 'meeting';
						if (events.some(e => e.category === 'deadline')) return 'deadline';
						if (events.some(e => e.category === 'reminder')) return 'reminder';
						if (events.some(e => e.category === 'standard')) return 'standard';
						if (events.some(e => e.category === 'low')) return 'low';
						return 'standard';
					},

					generateMiniCalendar() {
						const year = this.currentDate.getFullYear();
						const month = this.currentDate.getMonth();
						const today = new Date();
						today.setHours(0, 0, 0, 0);

						// First day of the month
						const firstDay = new Date(year, month, 1);
						// Last day of the month
						const lastDay = new Date(year, month + 1, 0);
						// First day of the calendar grid (might be from previous month)
						const startDay = new Date(firstDay);
						startDay.setDate(startDay.getDate() - firstDay.getDay());

						this.miniCalendarDays = [];

						// Generate 42 days (6 weeks)
						for (let i = 0; i < 42; i++) {
							const currentDate = new Date(startDay);
							currentDate.setDate(startDay.getDate() + i);
							currentDate.setHours(0, 0, 0, 0); // Ensure midnight local time

							// Use local date formatting instead of toISOString() to avoid timezone issues
							const dateStr = this.formatDateLocal(currentDate);
							const todayStr = this.formatDateLocal(today);

							// Check for events on this date
							const dayEvents = this.getEventsForDate(dateStr);
							const hasEvents = dayEvents.length > 0;
							const priorityCategory = hasEvents ? this.getHighestPriorityCategory(dayEvents) : null;
							const eventColor = priorityCategory ? this.getCategoryColor(priorityCategory) : null;

							this.miniCalendarDays.push({
								date: dateStr,
								day: currentDate.getDate(),
								isCurrentMonth: currentDate.getMonth() === month,
								isToday: dateStr === todayStr,
								isSelected: false,
								hasEvents: hasEvents,
								eventColor: eventColor,
								eventCount: dayEvents.length
							});
						}
					},

					navigateMiniCalendar(direction) {
						// Create a new Date object to ensure Vue reactivity detects the change
						// setMonth() automatically handles year transitions (e.g., Dec -> Jan)
						const newDate = new Date(this.currentDate);
						newDate.setMonth(this.currentDate.getMonth() + direction);
						
						// Assign new Date object to trigger Vue reactivity
						this.currentDate = new Date(newDate.getFullYear(), newDate.getMonth(), 1);
						
						this.generateMiniCalendar();
						this.fetchEvents(); // Reload events when navigating months

						// Sync main calendar to the same month
						if (window.customCalendar) {
							const targetYear = this.currentDate.getFullYear();
							const targetMonth = this.currentDate.getMonth();
							const firstDayOfMonth = new Date(targetYear, targetMonth, 1);
							
							// Update main calendar's selected date
							if (typeof window.customCalendar.gotoDate === 'function') {
								window.customCalendar.gotoDate(firstDayOfMonth);
							}
							
							// If main calendar is in month view, ensure it shows the correct month
							if (window.customCalendar.currentView === 'dayGridMonth') {
								// Update the calendar's internal date for month view
								window.customCalendar.selectedDate = new Date(targetYear, targetMonth, 1);
								window.customCalendar.currentDate = new Date(targetYear, targetMonth, 1);
								// Update title to reflect the new month/year
								const titleElement = document.getElementById('calendarTitle');
								if (titleElement && typeof window.customCalendar.updateTitle === 'function') {
									window.customCalendar.updateTitle(titleElement);
								}
								window.customCalendar.render();
							}
							
							// Load events for the new month
							if (typeof window.loadEvents === 'function') {
								window.loadEvents(firstDayOfMonth);
							}
						}
					},

				selectMiniCalendarDay(day) {
					// Reset all selections
					this.miniCalendarDays.forEach(d => d.isSelected = false);
					day.isSelected = true;

					// Parse date string as local date to avoid timezone issues
					// day.date is in format "YYYY-MM-DD", parse it as local date
					const dateParts = day.date.split('-');
					// Create date with explicit year, month, day, and set to midnight
					// This ensures no timezone shifting occurs (same as admin calendar)
					const localDate = new Date(
						parseInt(dateParts[0]),
						parseInt(dateParts[1]) - 1, // Month is 0-indexed
						parseInt(dateParts[2]),
						0, // hours
						0, // minutes
						0, // seconds
						0  // milliseconds
					);

					// Update main calendar view if custom calendar is available
					// Use navigateToDate for consistency and proper event loading (same as admin calendar)
					if (window.customCalendar && typeof window.customCalendar.navigateToDate === 'function') {
						window.customCalendar.navigateToDate(localDate);
					} else if (window.customCalendar) {
						// Fallback handling (same as admin calendar)
						window.customCalendar.gotoDate(localDate);
						window.customCalendar.changeView('timeGridDay');
						if (typeof window.loadEvents === 'function') {
							window.loadEvents(localDate);
						}
					}
				},

					updateCalendarFilters() {
						// Update calendar events based on filters
						if (window.customCalendar && typeof window.customCalendar.applyFilters === 'function') {
							window.customCalendar.applyFilters(this.filters);
						}
					},

					initializeCustomCalendar() {
						// Initialize the custom calendar with Vue integration
						if (typeof initCustomCalendar === 'function') {
							initCustomCalendar(this);
						}
						// Also set window.openModal after calendar-custom.js initializes
						// Use setTimeout to ensure calendar-custom.js has finished initializing
						setTimeout(() => {
							if (typeof initCustomCalendar === 'function') {
								initCustomCalendar(this);
							}
						}, 500);
					},

					// Modal methods
					openMemoModal(event = null, readOnly = false) {
						const hasExistingId = !!(event && event.id);
						this.isEditing = hasExistingId;
						this.isReadOnlyView = readOnly;

						if (event) {
							// Use provided event data (for both edit and prefilled new events)
							this.editingEvent = {
								id: event.id || '',
								source: event.source || '',
								title: event.title || '',
								date: event.date || this.getTodayDate(),
								endDate: event.endDate || event.date || this.getTodayDate(),
								category: event.category || 'standard',
								startTime: event.startTime || '09:00',
								endTime: event.endTime || '10:00',
								description: event.description || '',
								participants: event.participants ? [...event.participants] : []
							};
							this.selectedEvent = hasExistingId ? { ...event } : null;
						} else {
							// Brand-new event with defaults
							const today = this.getTodayDate();
							this.editingEvent = {
								id: '',
								source: '',
								title: '',
								date: today,
								endDate: today,
								category: 'standard',
								startTime: '09:00',
								endTime: '10:00',
								description: '',
								participants: []
							};
							this.selectedEvent = null;
						}

						this.showMemoModal = true;
					},

					closeMemoModal() {
						this.showMemoModal = false;
						this.isEditing = false;
						this.isReadOnlyView = false;
						this.selectedEvent = null;
						this.participantSearch = '';
						this.participantSuggestions = [];
					},

					// Event CRUD operations
					async saveEvent() {
						try {
							this.showSuccessModal = true;
							this.successLoading = true;
							this.successMessage = 'Saving event...';

							// Validate event data
							if (!this.validateEvent()) {
								this.showSuccessModal = false;
								return;
							}

							// Prepare participants array
							const participantsArray = this.editingEvent.participants.map(p => ({
								id: p.id,
								email: p.email,
								name: p.name,
								type: p.type || 'user'
							}));

							// Optionally add secretary's department as a department participant
							if (!this.isEditing && this.sendToDepartment && this.currentUser.department) {
								const deptName = this.currentUser.department;
								const deptId = `dept:${deptName}`;
								if (!participantsArray.some(p => p.type === 'department' && p.name === deptName)) {
									participantsArray.push({
										id: deptId,
										email: '',
										name: deptName,
										type: 'department'
									});
								}
							}

							// Prepare event data
							const eventData = {
								...this.editingEvent,
								createdBy: this.currentUser.id,
								participants: participantsArray
							};

							const url = this.isEditing ?
								`/api/calendar/events/${this.editingEvent.id}` :
								'/api/calendar/events';

							const method = this.isEditing ? 'PUT' : 'POST';

							const response = await fetch(url, {
								method: method,
								headers: {
									'Content-Type': 'application/json',
								},
								credentials: 'include',
								body: JSON.stringify(eventData)
							});

							if (response.ok) {
								this.successLoading = false;
								this.successMessage = this.isEditing ? 'Event updated successfully!' : 'Event created successfully!';

								setTimeout(() => {
									this.showSuccessModal = false;
									this.closeMemoModal();

									// Refresh calendar
									if (window.customCalendar && typeof window.customCalendar.refreshEvents === 'function') {
										window.customCalendar.refreshEvents();
									}
									// Refresh mini calendar events
									this.fetchEvents();
								}, 1500);
							} else {
								throw new Error('Failed to save event');
							}
						} catch (error) {
							console.error('Error saving event:', error);
							this.showSuccessModal = false;
							this.showAlert('Error', 'Failed to save event. Please try again.');
						}
					},

					validateEvent() {
						if (!this.editingEvent.title.trim()) {
							this.showAlert('Validation Error', 'Please enter a title for the event.');
							return false;
						}

						if (!this.editingEvent.date) {
							this.showAlert('Validation Error', 'Please select a date.');
							return false;
						}

						if (!this.editingEvent.startTime || !this.editingEvent.endTime) {
							this.showAlert('Validation Error', 'Please select both start and end times.');
							return false;
						}

						const start = new Date(`${this.editingEvent.date}T${this.editingEvent.startTime}`);
						const end = new Date(`${this.editingEvent.date}T${this.editingEvent.endTime}`);

						if (end <= start) {
							this.showAlert('Validation Error', 'End time must be after start time.');
							return false;
						}

						return true;
					},

					async deleteEvent() {
						this.showConfirm(
							'Delete Event',
							'Are you sure you want to delete this event? This action cannot be undone.',
							async () => {
								try {
									const response = await fetch(`/api/calendar/events/${this.editingEvent.id}`, {
										method: 'DELETE',
										credentials: 'include'
									});

									if (response.ok) {
										this.closeMemoModal();

										// Refresh calendar
									if (window.customCalendar && typeof window.customCalendar.refreshEvents === 'function') {
										window.customCalendar.refreshEvents();
									}

									// Refresh mini calendar events
									this.fetchEvents();

									this.showAlert('Success', 'Event deleted successfully.');
									} else {
										throw new Error('Failed to delete event');
									}
								} catch (error) {
									console.error('Error deleting event:', error);
									this.showAlert('Error', 'Failed to delete event. Please try again.');
								}
							}
						);
					},

					async archiveEvent() {
						this.showConfirm(
							'Archive Event',
							'Are you sure you want to archive this event?',
							async () => {
								try {
									const response = await fetch(`/api/calendar/events/${this.editingEvent.id}`, {
										method: 'PUT',
										headers: {
											'Content-Type': 'application/json',
										},
										credentials: 'include',
										body: JSON.stringify({ category: 'archived' })
									});

									if (response.ok) {
										this.closeMemoModal();

										// Refresh calendar
									if (window.customCalendar && typeof window.customCalendar.refreshEvents === 'function') {
										window.customCalendar.refreshEvents();
									}

									// Refresh mini calendar events
									this.fetchEvents();

									this.showAlert('Success', 'Event archived successfully.');
									} else {
										throw new Error('Failed to archive event');
									}
								} catch (error) {
									console.error('Error archiving event:', error);
									this.showAlert('Error', 'Failed to archive event. Please try again.');
								}
							}
						);
					},

					// Participant methods
					async searchParticipants() {
						if (this.participantSearch.length < 2) {
							this.participantSuggestions = [];
							return;
						}

						try {
							const response = await fetch(`/api/users/search?q=${encodeURIComponent(this.participantSearch)}`, {
								credentials: 'include'
							});
							const data = await response.json();

							if (data && data.users) {
								this.participantSuggestions = data.users.filter(user =>
									!this.editingEvent.participants.some(p => p.id === user.id)
								);
							}
						} catch (error) {
							console.error('Error searching participants:', error);
							// Fallback to mock data for demo
							this.participantSuggestions = [
								{ id: 'user1', email: 'user1@example.com', name: 'John Doe' },
								{ id: 'user2', email: 'user2@example.com', name: 'Jane Smith' }
							].filter(user =>
								!this.editingEvent.participants.some(p => p.id === user.id) &&
								(user.name.toLowerCase().includes(this.participantSearch.toLowerCase()) ||
								 user.email.toLowerCase().includes(this.participantSearch.toLowerCase()))
							);
						}
					},

					addParticipant(participant) {
						if (!this.editingEvent.participants.some(p => p.id === participant.id)) {
							this.editingEvent.participants.push(participant);
						}
						this.participantSearch = '';
						this.participantSuggestions = [];
					},

					addParticipantFromSearch() {
						if (this.participantSearch.trim() && this.participantSuggestions.length > 0) {
							this.addParticipant(this.participantSuggestions[0]);
						} else if (this.participantSearch.trim()) {
							// Add as email if no suggestions
							this.addParticipant({
								id: this.participantSearch,
								email: this.participantSearch,
								name: this.participantSearch
							});
						}
					},

					removeParticipant(participant) {
						this.editingEvent.participants = this.editingEvent.participants.filter(
							p => p.id !== participant.id
						);
					},

					// Department methods replaced by simple checkbox (no dropdown)

					// Utility methods
					getCategoryLabel(category) {
						const labels = {
							standard: 'üü¢ Standard',
							urgent: 'üî¥ Urgent',
							high: 'üü† High Priority',
							meeting: 'üü£ Meeting',
							deadline: '‚è∞ Deadline',
							reminder: 'üîî Reminder',
							low: 'üîµ Low Priority'
						};
						return labels[category] || category;
					},

					formatDisplayDate(dateString) {
						if (!dateString) return 'Not set';
						return new Date(dateString).toLocaleDateString('en-US', {
							year: 'numeric',
							month: 'long',
							day: 'numeric'
						});
					},

					formatParticipantsDisplay(participants) {
						if (!participants || participants.length === 0) return 'None';
						return participants.map(p => p.name || p.email).join(', ');
					},

					getTodayDate() {
						return new Date().toISOString().split('T')[0];
					},

					// Modal utility methods
					showConfirm(title, message, callback) {
						this.confirmModalTitle = title;
						this.confirmModalMessage = message;
						this.confirmCallback = callback;
						this.showConfirmModal = true;
					},

					closeConfirmModal() {
						this.showConfirmModal = false;
						this.confirmCallback = null;
					},

					confirmAction() {
						if (this.confirmCallback) {
							this.confirmCallback();
						}
						this.closeConfirmModal();
					},

					showAlert(title, message) {
						this.alertModalTitle = title;
						this.alertModalMessage = message;
						this.showAlertModal = true;
					},

					closeAlertModal() {
						this.showAlertModal = false;
					}
				}
			});

			// Forward Vue warnings to server and console (with truncation to avoid large payloads)
			app.config.warnHandler = (msg, instance, trace) => {
				console.warn('[Vue warn][secretary-calendar]:', msg, trace || '');
				try {
					const payload = {
						message: String(msg).slice(0, 500), // limit size
						trace: String(trace || '').slice(0, 1000),
						route: window.location.pathname,
						role: window.currentUser?.role || null
					};
					fetch('/api/log/vue-warning', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						credentials: 'same-origin',
						body: JSON.stringify(payload)
					}).catch(() => {});
				} catch (e) {
					// Ignore failures
				}
			};

			app.mount('#app');

			// Re-initialize Lucide icons after Vue renders
			setTimeout(() => {
				if (typeof lucide !== 'undefined') {
					lucide.createIcons();
				}
			}, 100);
		});
	</script>

	<!-- Custom calendar integration script -->
	<script src="/js/calendar-custom.js"></script>
</body>
</html>
