<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archive | Memofy</title>
    <link rel="stylesheet" href="/css/secretary-memos.css">
    <link rel="stylesheet" href="/css/log.css">
    <link rel="stylesheet" href="/css/sec-topbar.css">
    <link rel="stylesheet" href="/css/sec-nav.css">
    <!-- Preconnect to Google Fonts for faster loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Google Analytics Tracking -->
    <%- include('google-analytics', { propertyId: typeof gaPropertyId !=='undefined' ? gaPropertyId : null }); %>

    <!-- Vue.js CDN - defer to not block rendering -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js" defer></script>
    <script src="/js/lucide.min.js" defer></script>
</head>

<body>
    <div id="app" class="dashboard-container">
        <%- include('../components/sec-nav'); %>

        <main class="main-content">
            <%- include('../components/sec-topbar'); %>

            <div class="dashboard-content" style="height: 630px; margin-top: 10px;">
                <div class="log-layout">

                    <!-- Archive Memo List Area -->
                    <section class="memo-list-area" style="flex:1 1 auto; border: none;">
                        <div class="memo-container" style="height: 620px">
                            <div class="memo-list-header">
                                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
                                    <i data-lucide="archive" style="width: 24px; height: 24px; color: #6366f1;"></i>
                                    <h2 style="margin: 0; font-size: 24px; font-weight: 600; color: #1f2937;">Archive</h2>
                                </div>
                                <div class="header-controls">
                                    <button @click="refreshArchive" class="icon-btn-sm" title="Refresh" :disabled="loading">
                                        <i data-lucide="rotate-cw"></i>
                                    </button>
                                </div>
                                <div class="department-filters">
                                    <div class="priority-dropdown-wrapper">
                                        <select v-model="filters.priority" class="priority-filter-dropdown">
                                            <option value="all">All Priorities</option>
                                            <option value="urgent">üî¥ Urgent</option>
                                            <option value="high">üü† High</option>
                                            <option value="medium">üü° Medium</option>
                                            <option value="low">üîµ Low</option>
                                        </select>
                                    </div>
                                    <div class="sort-dropdown-wrapper">
                                        <select v-model="filters.sort" class="sort-dropdown">
                                            <option value="newest">Newest</option>
                                            <option value="oldest">Oldest</option>
                                            <option value="priority">Priority</option>
                                            <option value="subject">Subject (A-Z)</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <div class="memo-list-container">
                                <div class="memo-list">
                                    <!-- Empty State -->
                                    <div v-if="filteredItems.length === 0" class="memo-item">
                                        <i data-lucide="archive" class="memo-icon"></i>
                                        <div class="memo-info">
                                            <h4>No archived items</h4>
                                            <p>Archived memos and calendar events will appear here</p>
                                        </div>
                                    </div>

                                    <!-- Memo/Event Items -->
                                    <div v-for="(item, index) in filteredItems"
                                         :key="item._id + '-' + item.type"
                                         class="memo-item archived-item"
                                         :class="{ 'archived-event': item.type === 'event' }"
                                         @click="selectItem(item, index)">

                                        <!-- Event Icon -->
                                        <i v-if="item.type === 'event'"
                                           data-lucide="calendar"
                                           class="memo-icon"
                                           style="width: 40px; height: 40px; color: #6366f1;"></i>

                                        <!-- Memo Avatar -->
                                        <img v-else
                                             :src="getAvatar(item)"
                                             :alt="getRecipientName(item)"
                                             class="memo-avatar"
                                             @error="handleAvatarError">

                                        <div class="memo-sender-info">
                                            <div class="memo-sender-name">
                                                {{ item.type === 'event' ? 'Calendar Event' : 'To: ' + getRecipientName(item) }}
                                            </div>
                                            <div class="memo-sender-email">
                                                {{ getSecondaryInfo(item) }}
                                            </div>
                                        </div>

                                        <div class="memo-item-actions">
                                            <span class="priority-badge" :class="getPriorityClass(item)">
                                                {{ getPriorityBadge(item) }}
                                            </span>
                                        </div>

                                        <div class="memo-subject">
                                            {{ item.type === 'event' ? (item.title || 'Untitled Event') : (item.subject || '') }}
                                        </div>

                                        <div class="memo-date">
                                            Archived: {{ formatDate(item.updatedAt || item.createdAt) }}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- Memo Viewer Modal -->
                    <div id="memoViewerModal" class="modal memo-viewer-modal" :style="{ display: viewerVisible ? 'block' : 'none' }" @click.self="clearSelection">
                        <div class="modal-content memo-viewer-modal-content">
                            <div v-if="selectedItem" class="memo-viewer">
                                <div class="viewer-header">
                                    <button @click="clearSelection" class="icon-btn" title="Close">
                                        <i data-lucide="x"></i>
                                    </button>
                                    <div class="nav-buttons">
                                        <button @click="navigateItem(-1)" class="icon-btn" :disabled="selectedIndex <= 0" title="Previous Memo">
                                            <i data-lucide="chevron-left"></i>
                                        </button>
                                        <span class="memo-counter">{{ selectedIndex + 1 }} of {{ filteredItems.length }}</span>
                                        <button @click="navigateItem(1)" class="icon-btn" :disabled="selectedIndex >= filteredItems.length - 1" title="Next Memo">
                                            <i data-lucide="chevron-right"></i>
                                        </button>
                                    </div>
                                    <div class="viewer-actions">
                                        <button class="icon-btn" title="Toggle Favorite">
                                            <i data-lucide="bookmark"></i>
                                        </button>
                                        <button @click="unarchiveItem" class="icon-btn" title="Unarchive Memo">
                                            <i data-lucide="archive-restore"></i>
                                        </button>
                                        <button class="icon-btn" title="Download Memo">
                                            <i data-lucide="download"></i>
                                        </button>
                                    </div>
                                </div>

                                <div class="memo-content">
                                    <div class="memo-pdf-header">
                                        <h1 class="memo-title">MEMO</h1>
                                        <div class="memo-details">
                                            <div class="memo-detail-row">
                                                <span class="memo-detail-label">Subject:</span>
                                                <span class="memo-detail-value">{{ selectedItem.type === 'event' ? (selectedItem.title || '(No title)') : (selectedItem.subject || '(No subject)') }}</span>
                                            </div>
                                            <div class="memo-detail-row">
                                                <span class="memo-detail-label">From:</span>
                                                <span class="memo-detail-value">{{ getSenderInfo(selectedItem) }}</span>
                                            </div>
                                            <div class="memo-detail-row">
                                                <span class="memo-detail-label">To:</span>
                                                <span class="memo-detail-value">{{ getRecipientInfo(selectedItem) }}</span>
                                            </div>
                                            <div class="memo-detail-row">
                                                <span class="memo-detail-label">Department:</span>
                                                <span class="memo-detail-value">{{ selectedItem.department || 'N/A' }}</span>
                                            </div>
                                            <div class="memo-detail-row">
                                                <span class="memo-detail-label">Priority:</span>
                                                <span class="memo-detail-value">{{ getPriorityLabel(selectedItem) }}</span>
                                            </div>
                                            <div class="memo-detail-row">
                                                <span class="memo-detail-label">Date:</span>
                                                <span class="memo-detail-value">{{ getDateInfo(selectedItem) }}</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="memo-body-content">
                                        <div style="white-space: pre-wrap; line-height: 1.6; color: #111827;">
                                            {{ selectedItem.type === 'event' ? (selectedItem.description || '(No description)') : (selectedItem.content || '') }}
                                        </div>
                                    </div>
                                    <div class="attachments-section"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Wait for Vue.js to load before initializing the app
        function initVueApp() {
            if (typeof Vue === 'undefined') {
                // Vue not loaded yet, wait a bit and try again
                setTimeout(initVueApp, 50);
                return;
            }

            const { createApp } = Vue;

            createApp({
            data() {
                return {
                    // User data
                    currentUser: {
                        id: '<%= user._id %>',
                        email: '<%= user.email %>',
                        role: '<%= user.role %>',
                        department: '<%= user.department || "" %>',
                        canCrossSend: <%= user.canCrossSend || false %>
                    },

                    // Archive data
                    allItems: [],
                    filteredItems: [],
                    selectedItem: null,
                    selectedIndex: -1,

                    // UI state
                    loading: false,
                    viewerVisible: false,

                    // Filters
                    filters: {
                        priority: 'all',
                        sort: 'newest'
                    }
                }
            },
            computed: {
                // Computed properties can be added here if needed
            },
            mounted() {
                // Initialize data
                this.initializeData();

                // Create Lucide icons
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }

                // Add keyboard support for modal (ESC to close)
                const self = this;
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape' && self.viewerVisible) {
                        self.clearSelection();
                    }
                });
            },
            watch: {
                // Watch filters and re-sort/filter when they change
                filters: {
                    handler() {
                        this.applyFilters();
                    },
                    deep: true
                }
            },
            methods: {
                // Initialize data from server-side variables
                initializeData() {
                    const archivedMemos = <%- JSON.stringify(archivedMemos || []) %>;
                    const archivedEvents = <%- JSON.stringify(archivedEvents || []) %>;

                    // Combine and transform data
                    this.allItems = [
                        ...(archivedMemos || []).map(m => ({ ...m, type: 'memo' })),
                        ...(archivedEvents || []).map(e => ({ ...e, type: 'event' }))
                    ];

                    // Apply initial sorting
                    this.applyFilters();
                },

                // Apply filters and sorting
                applyFilters() {
                    let filtered = [...this.allItems];

                    // Apply priority filter
                    if (this.filters.priority !== 'all') {
                        filtered = filtered.filter(item => {
                            if (item.type === 'event') {
                                const category = (item.category || '').toLowerCase();
                                // Map event categories to priority filter
                                if (this.filters.priority === 'urgent') return category === 'urgent' || category === 'deadline';
                                if (this.filters.priority === 'high') return category === 'high' || category === 'meeting';
                                if (this.filters.priority === 'medium') return category === 'standard' || category === 'reminder';
                                if (this.filters.priority === 'low') return category === 'low';
                                return false;
                            } else {
                                return (item.priority || '').toLowerCase() === this.filters.priority;
                            }
                        });
                    }

                    // Apply sorting
                    filtered.sort((a, b) => {
                        if (this.filters.sort === 'newest') {
                            const aDate = new Date(a.updatedAt || a.createdAt || 0);
                            const bDate = new Date(b.updatedAt || b.createdAt || 0);
                            return bDate - aDate;
                        }
                        if (this.filters.sort === 'oldest') {
                            const aDate = new Date(a.updatedAt || a.createdAt || 0);
                            const bDate = new Date(b.updatedAt || b.createdAt || 0);
                            return aDate - bDate;
                        }
                        if (this.filters.sort === 'priority') {
                            const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };
                            const aPriority = this.getItemPriority(a);
                            const bPriority = this.getItemPriority(b);
                            return (priorityOrder[bPriority] || 0) - (priorityOrder[aPriority] || 0);
                        }
                        if (this.filters.sort === 'subject') {
                            const aTitle = a.type === 'event' ? (a.title || '') : (a.subject || '');
                            const bTitle = b.type === 'event' ? (b.title || '') : (b.subject || '');
                            return aTitle.localeCompare(bTitle);
                        }
                        return 0;
                    });

                    this.filteredItems = filtered;

                    // Update selected index if an item was selected
                    if (this.selectedItem) {
                        const newIndex = this.filteredItems.findIndex(item =>
                            item._id === this.selectedItem._id && item.type === this.selectedItem.type
                        );
                        if (newIndex !== -1) {
                            this.selectedIndex = newIndex;
                        } else {
                            this.clearSelection();
                        }
                    }
                },

                // Get priority for sorting/filtering
                getItemPriority(item) {
                    if (item.type === 'event') {
                        if (item.category === 'urgent' || item.category === 'deadline') return 'urgent';
                        if (item.category === 'high' || item.category === 'meeting') return 'high';
                        if (item.category === 'low') return 'low';
                        return 'medium';
                    } else {
                        return (item.priority || 'medium').toLowerCase();
                    }
                },

                // Select an item to view
                async selectItem(item, index) {
                    this.selectedIndex = index;

                    // For memos, try to fetch full details
                    if (item.type === 'memo' && !item.content) {
                        try {
                            this.loading = true;
                            const response = await fetch(`/api/log/memos/${item._id}`);
                            const data = await response.json();
                            if (data && data.success && data.memo) {
                                this.selectedItem = { ...data.memo, type: 'memo' };
                            } else {
                                this.selectedItem = item;
                            }
                        } catch (error) {
                            console.error('Error fetching memo details:', error);
                            this.selectedItem = item;
                        } finally {
                            this.loading = false;
                        }
                    } else {
                        this.selectedItem = item;
                    }

                    this.viewerVisible = true;
                    // Prevent body scrolling when modal is open
                    document.body.style.overflow = 'hidden';
                    // Reinitialize Lucide icons in modal
                    this.$nextTick(() => {
                        if (typeof lucide !== 'undefined') {
                            lucide.createIcons();
                        }
                    });
                },

                // Clear selection
                clearSelection() {
                    this.selectedItem = null;
                    this.selectedIndex = -1;
                    this.viewerVisible = false;
                    // Restore body scrolling
                    document.body.style.overflow = '';
                },

                // Navigate between items
                navigateItem(direction) {
                    const newIndex = this.selectedIndex + direction;
                    if (newIndex >= 0 && newIndex < this.filteredItems.length) {
                        this.selectItem(this.filteredItems[newIndex], newIndex);
                        // Refresh icons after navigation
                        this.$nextTick(() => {
                            if (typeof lucide !== 'undefined') {
                                lucide.createIcons();
                            }
                        });
                    }
                },

                // Unarchive current item
                async unarchiveItem() {
                    if (!this.selectedItem) return;

                    try {
                        this.loading = true;

                        if (this.selectedItem.type === 'event') {
                            // Unarchive calendar event
                            const response = await fetch(`/api/calendar/events/${this.selectedItem._id}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                credentials: 'same-origin',
                                body: JSON.stringify({ category: 'standard' })
                            });

                            if (response.ok) {
                                this.removeItemFromList();
                                this.showNotification('Event unarchived successfully', 'success');
                            }
                        } else {
                            // Unarchive memo
                            const response = await fetch(`/api/log/memos/${this.selectedItem._id}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                credentials: 'same-origin',
                                body: JSON.stringify({ status: 'sent' })
                            });

                            const data = await response.json();
                            if (data && data.success) {
                                this.removeItemFromList();
                                this.showNotification('Memo unarchived successfully', 'success');
                            }
                        }
                    } catch (error) {
                        console.error('Error unarchiving item:', error);
                        this.showNotification('Error unarchiving item', 'error');
                    } finally {
                        this.loading = false;
                    }
                },

                // Remove item from lists after unarchiving
                removeItemFromList() {
                    this.allItems = this.allItems.filter(item =>
                        !(item._id === this.selectedItem._id && item.type === this.selectedItem.type)
                    );
                    this.applyFilters();
                    this.clearSelection();
                },

                // Refresh archive data
                async refreshArchive() {
                    try {
                        this.loading = true;
                        const response = await fetch('/api/log/memos?folder=archive', {
                            credentials: 'same-origin'
                        });
                        const data = await response.json();

                        if (data && data.success && Array.isArray(data.memos)) {
                            // Update memos (events would need a separate API call)
                            const updatedMemos = data.memos.map(m => ({ ...m, type: 'memo' }));

                            // For now, keep existing events and update memos
                            const existingEvents = this.allItems.filter(item => item.type === 'event');
                            this.allItems = [...updatedMemos, ...existingEvents];

                            this.applyFilters();
                            this.showNotification('Archive refreshed', 'success');
                        }
                    } catch (error) {
                        console.error('Error refreshing archive:', error);
                        this.showNotification('Error refreshing archive', 'error');
                    } finally {
                        this.loading = false;
                    }
                },

                // Utility methods for display
                getAvatar(item) {
                    if (item.type === 'event') return '';
                    const realAvatar = item.recipient?.profilePicture;
                    return realAvatar || '/images/memofy-logo.png';
                },

                handleAvatarError(event) {
                    event.target.src = '/images/memofy-logo.png';
                },

                getRecipientName(item) {
                    if (item.type === 'event') return '';
                    return ((item.recipient?.firstName || '') + ' ' + (item.recipient?.lastName || '')).trim() || 'Unknown';
                },

                getSecondaryInfo(item) {
                    if (item.type === 'event') {
                        const dateStr = new Date(item.start).toLocaleDateString();
                        const startTime = new Date(item.start).toLocaleTimeString('en-US', {
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                        const endTime = new Date(item.end).toLocaleTimeString('en-US', {
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                        return `${dateStr} ‚Ä¢ ${startTime} - ${endTime}`;
                    } else {
                        return item.recipient?.email || '';
                    }
                },

                getPriorityClass(item) {
                    if (item.type === 'event') {
                        const category = item.category || 'standard';
                        return `priority-${category === 'urgent' || category === 'deadline' ? 'urgent' :
                                category === 'high' || category === 'meeting' ? 'high' :
                                category === 'low' ? 'low' : 'medium'}`;
                    } else {
                        return `priority-${(item.priority || 'medium').toLowerCase()}`;
                    }
                },

                getPriorityBadge(item) {
                    if (item.type === 'event') {
                        const category = item.category || 'standard';
                        const badges = {
                            urgent: 'üî¥ URGENT',
                            high: 'üü† HIGH',
                            meeting: 'üü£ MEETING',
                            deadline: '‚è∞ DEADLINE',
                            reminder: 'üîî REMINDER',
                            low: 'üîµ LOW',
                            standard: 'üü¢ STANDARD'
                        };
                        return badges[category] || 'üü¢ STANDARD';
                    } else {
                        const priority = (item.priority || '').toLowerCase();
                        const badges = {
                            urgent: 'üî¥ URGENT',
                            high: 'üü† HIGH',
                            medium: 'üü° MEDIUM',
                            low: 'üîµ LOW'
                        };
                        return badges[priority] || 'üü° MEDIUM';
                    }
                },

                formatDate(dateString) {
                    return new Date(dateString).toLocaleDateString();
                },

                getSenderInfo(item) {
                    if (item.type === 'event') {
                        const creatorName = ((item.createdBy?.firstName || '') + ' ' + (item.createdBy?.lastName || '')).trim();
                        return (creatorName || 'Unknown') + ' (' + (item.createdBy?.email || '') + ')';
                    } else {
                        const senderName = ((item.sender?.firstName || '') + ' ' + (item.sender?.lastName || '')).trim();
                        return (senderName || 'Unknown') + ' (' + (item.sender?.email || '') + ')';
                    }
                },

                getRecipientInfo(item) {
                    if (item.type === 'event') {
                        let participantsText = 'None';
                        if (item.participants) {
                            const parts = [];
                            if (item.participants.departments && Array.isArray(item.participants.departments) && item.participants.departments.length > 0) {
                                parts.push('Departments: ' + item.participants.departments.join(', '));
                            }
                            if (item.participants.emails && Array.isArray(item.participants.emails) && item.participants.emails.length > 0) {
                                const emailList = item.participants.emails.map(e => typeof e === 'string' ? e : e.email).join(', ');
                                parts.push('Emails: ' + emailList);
                            }
                            participantsText = parts.length > 0 ? parts.join('; ') : 'None';
                        }
                        return participantsText;
                    } else {
                        const recipName = ((item.recipient?.firstName || '') + ' ' + (item.recipient?.lastName || '')).trim();
                        return (recipName || 'Unknown') + ' (' + (item.recipient?.email || '') + ')';
                    }
                },

                getPriorityLabel(item) {
                    const labels = {
                        urgent: 'üî¥ Urgent',
                        high: 'üü† High Priority',
                        medium: 'üü¢ Standard',
                        meeting: 'üü£ Meeting',
                        deadline: '‚è∞ Deadline',
                        reminder: 'üîî Reminder',
                        low: 'üîµ Low Priority'
                    };

                    if (item.type === 'event') {
                        return labels[item.category] || item.category || 'Standard';
                    } else {
                        return labels[item.priority] || item.priority || 'Medium';
                    }
                },

                getDateInfo(item) {
                    if (item.type === 'event') {
                        const startDate = new Date(item.start);
                        const endDate = new Date(item.end);
                        const dateStr = startDate.toLocaleDateString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            year: 'numeric'
                        });
                        const startTime = startDate.toLocaleTimeString('en-US', {
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                        const endTime = endDate.toLocaleTimeString('en-US', {
                            hour: 'numeric',
                            minute: '2-digit'
                        });
                        return `${dateStr} ‚Ä¢ ${startTime} - ${endTime}`;
                    } else {
                        return new Date(item.createdAt).toLocaleString();
                    }
                },

                // Notification helper (you might want to integrate with your existing notification system)
                showNotification(message, type = 'info') {
                    // This is a placeholder - integrate with your existing notification system
                    console.log(`${type.toUpperCase()}: ${message}`);
                    // Example: if you have a showNotification function globally
                    if (typeof showNotification === 'function') {
                        showNotification(message, type);
                    }
                }
            }
            }).mount('#app');
        }

        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initVueApp);
        } else {
            // DOM already loaded, start immediately
            initVueApp();
        }
    </script>
</body>
</html>
