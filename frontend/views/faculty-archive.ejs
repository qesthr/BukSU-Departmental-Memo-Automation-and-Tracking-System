<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archive | Memofy</title>
    <link rel="stylesheet" href="/css/faculty-memos.css">
    <link rel="stylesheet" href="/css/log.css">
    <link rel="stylesheet" href="/css/fal-topbar.css">
    <link rel="stylesheet" href="/css/fal-nav.css">
    <!-- Preconnect to Google Fonts for faster loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Google Analytics Tracking -->
    <%- include('google-analytics', { propertyId: typeof gaPropertyId !=='undefined' ? gaPropertyId : null }); %>

    <!-- Vue 3 CDN (must load before inline Vue app script) -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="/js/lucide.min.js" defer></script>
</head>

<body
    data-current-user='<%- JSON.stringify({
        id: user._id,
        email: user.email,
        role: user.role,
        department: user.department || ""
    }) %>'
    data-archived-memos='<%- JSON.stringify(archivedMemos || []) %>'>

    <div id="app" class="dashboard-container">
        <%- include('../components/fal-nav'); %>

        <main class="main-content">
            <%- include('../components/fal-topbar'); %>

            <div class="dashboard-content" style="margin-top: 10px; height: 630px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); border-radius: 10px;">
                <div class="log-layout" style="border: none;">
                    <!-- Archive Memo List Area -->
                    <section class="memo-list-area" style="flex:1 1 auto; border: none;">
                        <div class="memo-container" style="height: 620px; border: none;">
                            <div class="memo-list-header">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
                                    <div style="display: flex; align-items: center; gap: 12px;">
                                        <i data-lucide="archive" style="width: 24px; height: 24px; color: #6366f1;"></i>
                                        <h2 style="margin: 0; font-size: 24px; font-weight: 600; color: #1f2937;">Archived Received Memos</h2>
                                    </div>
                                </div>
                                <div class="department-filters">
                                    <div class="priority-dropdown-wrapper">
                                        <select v-model="filters.priority" class="priority-filter-dropdown">
                                            <option value="all">All Priorities</option>
                                            <option value="urgent">ðŸ”´ Urgent</option>
                                            <option value="high">ðŸŸ  High</option>
                                            <option value="medium">ðŸŸ¡ Medium</option>
                                            <option value="low">ðŸ”µ Low</option>
                                        </select>
                                    </div>
                                    <div class="sort-dropdown-wrapper">
                                        <select v-model="filters.sortBy" class="sort-dropdown">
                                            <option value="newest">Newest</option>
                                            <option value="oldest">Oldest</option>
                                            <option value="priority">Priority</option>
                                            <option value="subject">Subject (A-Z)</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <div class="memo-list-container">
                                <div class="memo-list">
                                    <div v-if="filteredMemos.length === 0" class="memo-item">
                                        <i data-lucide="archive" class="memo-icon"></i>
                                        <div class="memo-info">
                                            <h4>No archived memos</h4>
                                            <p>Archived received memos will appear here</p>
                                        </div>
                                    </div>

                                    <div
                                        v-for="(memo, index) in filteredMemos"
                                        :key="memo._id"
                                        class="memo-item archived-item"
                                        @click="openMemo(memo)"
                                    >
                                        <img
                                            :src="getAvatar(memo.sender)"
                                            :alt="getSenderName(memo.sender)"
                                            class="memo-avatar"
                                            @error="handleAvatarError"
                                        >
                                        <div class="memo-sender-info">
                                            <div class="memo-sender-name">From: {{ getSenderName(memo.sender) }}</div>
                                            <div class="memo-sender-email">{{ memo.sender?.email || '' }}</div>
                                        </div>
                                        <div class="memo-subject">{{ memo.subject || '(No subject)' }}</div>
                                        <div class="memo-item-actions">
                                            <span :class="getPriorityClass(memo.priority)" :title="memo.priority">
                                                {{ getPriorityBadge(memo.priority) }}
                                            </span>
                                        </div>
                                        <div class="memo-date">{{ formatDate(memo.createdAt) }}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <!-- Memo Viewer Modal (match memos modal style) -->
                    <div
                        id="memoViewerModal"
                        class="modal memo-viewer-modal"
                        :style="{ display: viewerVisible ? 'flex' : 'none' }"
                        @click.self="closeViewer"
                    >
                        <div class="modal-content memo-viewer-modal-content">
                            <div class="memo-viewer">
                                <div v-if="!viewerVisible || !currentMemo" class="empty-state-view">
                                    <i data-lucide="archive"></i>
                                    <p>Select a memo to view</p>
                                </div>

                                <div v-else>
                                    <div class="viewer-header">
                                        <button @click="closeViewer" id="backBtn" class="icon-btn" title="Close">
                                            <i data-lucide="x"></i>
                                        </button>
                                        <div class="nav-buttons">
                                            <button @click="prevMemo" class="icon-btn" :disabled="currentMemoIndex === 0" title="Previous Memo">
                                                <i data-lucide="chevron-left"></i>
                                            </button>
                                            <span class="memo-counter">{{ currentMemoIndex + 1 }} of {{ filteredMemos.length }}</span>
                                            <button @click="nextMemo" class="icon-btn" :disabled="currentMemoIndex === filteredMemos.length - 1" title="Next Memo">
                                                <i data-lucide="chevron-right"></i>
                                            </button>
                                        </div>
                                        <div class="viewer-actions">
                                            <button @click="toggleFavorite" class="icon-btn" title="Toggle Favorite">
                                                <i data-lucide="bookmark"></i>
                                            </button>
                                            <button @click="unarchiveCurrentMemo" class="icon-btn" title="Unarchive Memo">
                                                <i data-lucide="archive-restore"></i>
                                            </button>
                                            <button @click="downloadMemo" class="icon-btn" title="Download Memo">
                                                <i data-lucide="download"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="memo-content">
                                        <div class="memo-gmail-header">
                                            <h2 class="memo-subject-title">{{ currentMemo.subject || '(No subject)' }}</h2>
                                            <div class="memo-sender-header">
                                                <img :src="getAvatar(currentMemo.sender)" :alt="getSenderName(currentMemo.sender)"
                                                    class="memo-sender-avatar-img" @error="handleAvatarError">
                                                <div class="memo-sender-info-header">
                                                    <div class="memo-sender-name-header">{{ getSenderName(currentMemo.sender) }}</div>
                                                    <div class="memo-sender-email-header">{{ currentMemo.sender?.email || '' }}</div>
                                                </div>
                                            </div>
                                            <div class="memo-to-dropdown-header" style="cursor: pointer; padding: 8px 0; color: #6b7280; font-size: 13px;">
                                                <span style="text-decoration: underline;">to me</span>
                                                <i data-lucide="chevron-down" style="width: 16px; height: 16px; margin-left: 4px;"></i>
                                            </div>
                                        </div>
                                        <div class="memo-body">
                                            <div class="memo-body-content" v-html="getMemoContent(currentMemo)"></div>
                                        </div>
                                        <div v-if="currentMemo.attachments && currentMemo.attachments.length > 0" class="memo-attachments">
                                            <h3 style="margin: 20px 0 10px; font-size: 16px; font-weight: 600;">Attachments:</h3>
                                            <div v-for="(attachment, attIndex) in currentMemo.attachments" :key="attachment.filename" style="margin: 8px 0;">
                                                <a href="#"
                                                   @click.prevent="openAttachmentModal(currentMemo.attachments, attIndex)"
                                                   style="color: #1C89E3; text-decoration: none; display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                                    <i data-lucide="paperclip" style="width: 16px; height: 16px;"></i>
                                                    <span>{{ attachment.filename || 'Attachment' }}</span>
                                                </a>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Attachment Viewer Modal -->
                    <div id="attachmentViewerModal" class="modal" :style="{ display: attachmentModalVisible ? 'block' : 'none' }" @click.self="closeAttachmentModal" style="position: fixed; z-index: 100002; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); overflow: auto;">
                        <div style="position: relative; background-color: #fff; margin: 2% auto; padding: 0; width: 90%; max-width: 1200px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-height: 90vh; display: flex; flex-direction: column;">
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; border-bottom: 1px solid #e5e7eb;">
                                <div style="flex: 1;">
                                    <h3 id="facultyArchiveFileName" style="margin: 0; font-size: 1.125rem; font-weight: 600; color: #111827;"></h3>
                                    <p id="facultyArchiveFileSize" style="margin: 0.25rem 0 0 0; font-size: 0.875rem; color: #6b7280;"></p>
                                </div>
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <button id="facultyArchivePrevBtn" @click="prevAttachment" style="display: none; padding: 0.5rem; background: #f3f4f6; border: none; border-radius: 6px; cursor: pointer;" title="Previous">
                                        <i data-lucide="chevron-left" style="width: 20px; height: 20px;"></i>
                                    </button>
                                    <button id="facultyArchiveNextBtn" @click="nextAttachment" style="display: none; padding: 0.5rem; background: #f3f4f6; border: none; border-radius: 6px; cursor: pointer;" title="Next">
                                        <i data-lucide="chevron-right" style="width: 20px; height: 20px;"></i>
                                    </button>
                                    <a id="facultyArchiveDownloadBtn" href="#" download style="padding: 0.5rem 1rem; background: #2563eb; color: white; border: none; border-radius: 6px; cursor: pointer; text-decoration: none; display: inline-flex; align-items: center; gap: 0.5rem; font-weight: 500; font-size: 0.875rem;" title="Download">
                                        <i data-lucide="download" style="width: 18px; height: 18px;"></i>
                                        <span>Download</span>
                                    </a>
                                    <button @click="closeAttachmentModal" style="padding: 0.5rem; background: #f3f4f6; border: none; border-radius: 6px; cursor: pointer; font-size: 1.5rem; line-height: 1; color: #6b7280;" title="Close">Ã—</button>
                                </div>
                            </div>
                            <div style="flex: 1; overflow: auto; padding: 1.5rem; display: flex; align-items: center; justify-content: center; min-height: 400px; background: #f9fafb;">
                                <div id="facultyArchiveAttachmentContent" style="width: 100%; text-align: center;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    archivedMemos: [],
                    currentMemo: null,
                    currentMemoIndex: -1,
                    viewerVisible: false,
                    attachmentModalVisible: false,
                    currentAttachments: [],
                    currentAttachmentIndex: 0,
                    filters: {
                        priority: 'all',
                        sortBy: 'newest'
                    }
                };
            },
            computed: {
                filteredMemos() {
                    let memos = [...this.archivedMemos];

                    if (this.filters.priority !== 'all') {
                        memos = memos.filter(memo => (memo.priority || '').toLowerCase() === this.filters.priority);
                    }

                    memos.sort((a, b) => {
                        switch (this.filters.sortBy) {
                            case 'newest':
                                return new Date(b.createdAt) - new Date(a.createdAt);
                            case 'oldest':
                                return new Date(a.createdAt) - new Date(b.createdAt);
                            case 'priority':
                                const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };
                                return (priorityOrder[(b.priority || '').toLowerCase()] || 0) -
                                       (priorityOrder[(a.priority || '').toLowerCase()] || 0);
                            case 'subject':
                                return (a.subject || '').localeCompare(b.subject || '');
                            default:
                                return 0;
                        }
                    });

                    return memos;
                }
            },
            mounted() {
                this.loadInitialData();
                this.refreshLucideIcons();
            },
            methods: {
                loadInitialData() {
                    try {
                        const memoData = document.body.getAttribute('data-archived-memos');
                        if (memoData) {
                            this.archivedMemos = JSON.parse(memoData);
                        }
                    } catch (error) {
                        console.error('Error parsing archived memo data:', error);
                    }
                },

                refreshLucideIcons() {
                    if (typeof lucide !== 'undefined') {
                        lucide.createIcons();
                    }
                },

                refreshArchive() {
                    window.location.reload();
                },

                getSenderName(sender) {
                    if (!sender) return 'Unknown';
                    return `${sender.firstName || ''} ${sender.lastName || ''}`.trim() || 'Unknown';
                },

                getRecipientName(recipient) {
                    if (!recipient) return 'Unknown';
                    return `${recipient.firstName || ''} ${recipient.lastName || ''}`.trim() || 'Unknown';
                },

                getAvatar(sender) {
                    return sender?.profilePicture || '/images/memofy-logo.png';
                },

                handleAvatarError(event) {
                    event.target.src = '/images/memofy-logo.png';
                },

                getPriorityBadge(priority) {
                    const pr = (priority || '').toLowerCase();
                    switch (pr) {
                        case 'urgent': return 'ðŸ”´ URGENT';
                        case 'high': return 'ðŸŸ  HIGH';
                        case 'medium': return 'ðŸŸ¡ MEDIUM';
                        case 'low': return 'ðŸ”µ LOW';
                        default: return '';
                    }
                },

                getPriorityClass(priority) {
                    const pr = (priority || '').toLowerCase();
                    return `priority-badge priority-${pr}`;
                },

                formatDate(dateString) {
                    return new Date(dateString).toLocaleDateString();
                },

                formatDateTime(dateString) {
                    return new Date(dateString).toLocaleString();
                },

                getMemoContent(memo) {
                    if (memo.htmlContent) {
                        return memo.htmlContent;
                    }

                    const safeContent = (memo.content || '')
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                    return `<div style="white-space: pre-wrap; line-height: 1.6; color: #111827;">${safeContent}</div>`;
                },

                async openMemo(memo) {
                    if (!memo) return;

                    try {
                        const response = await fetch(`/api/log/memos/${memo._id}`);
                        const data = await response.json();

                        if (data && data.success && data.memo) {
                            this.currentMemo = data.memo;
                        } else {
                            this.currentMemo = memo;
                        }
                    } catch (error) {
                        console.error('Error fetching memo details:', error);
                        this.currentMemo = memo;
                    }

                    this.currentMemoIndex = this.filteredMemos.findIndex(m => m._id === memo._id);
                    this.viewerVisible = true;
                    document.body.style.overflow = 'hidden';
                    this.$nextTick(() => this.refreshLucideIcons());
                },

                closeViewer() {
                    this.currentMemo = null;
                    this.currentMemoIndex = -1;
                    this.viewerVisible = false;
                    document.body.style.overflow = '';
                },

                async prevMemo() {
                    if (this.currentMemoIndex > 0) {
                        this.currentMemoIndex--;
                        const memo = this.filteredMemos[this.currentMemoIndex];

                        try {
                            const response = await fetch(`/api/log/memos/${memo._id}`);
                            const data = await response.json();
                            if (data && data.success && data.memo) {
                                this.currentMemo = data.memo;
                            } else {
                                this.currentMemo = memo;
                            }
                        } catch (error) {
                            console.error('Error fetching memo details:', error);
                            this.currentMemo = memo;
                        }

                        this.$nextTick(() => this.refreshLucideIcons());
                    }
                },

                async nextMemo() {
                    if (this.currentMemoIndex < this.filteredMemos.length - 1) {
                        this.currentMemoIndex++;
                        const memo = this.filteredMemos[this.currentMemoIndex];

                        try {
                            const response = await fetch(`/api/log/memos/${memo._id}`);
                            const data = await response.json();
                            if (data && data.success && data.memo) {
                                this.currentMemo = data.memo;
                            } else {
                                this.currentMemo = memo;
                            }
                        } catch (error) {
                            console.error('Error fetching memo details:', error);
                            this.currentMemo = memo;
                        }

                        this.$nextTick(() => this.refreshLucideIcons());
                    }
                },

                async unarchiveCurrentMemo() {
                    if (!this.currentMemo) return;

                    try {
                        const response = await fetch(`/api/log/memos/${this.currentMemo._id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'same-origin',
                            body: JSON.stringify({ status: 'sent' })
                        });

                        const data = await response.json();
                        if (data && data.success) {
                            this.archivedMemos = this.archivedMemos.filter(m => m._id !== this.currentMemo._id);
                            this.closeViewer();

                            if (typeof showNotification === 'function') {
                                showNotification('Memo unarchived successfully', 'success');
                            }
                        }
                    } catch (error) {
                        console.error('Error unarchiving memo:', error);
                    }
                },

                toggleFavorite() {
                    console.log('Toggle favorite', this.currentMemo?._id);
                },

                downloadMemo() {
                    console.log('Download memo', this.currentMemo?._id);
                },

                openAttachmentModal(attachments, index) {
                    this.currentAttachments = attachments;
                    this.currentAttachmentIndex = index;
                    this.attachmentModalVisible = true;
                    document.body.style.overflow = 'hidden';
                    this.$nextTick(() => {
                        this.refreshLucideIcons();
                        this.updateAttachmentViewer();
                        // Ensure modal is on top
                        const modal = document.getElementById('attachmentViewerModal');
                        if (modal) {
                            modal.style.zIndex = '100002';
                        }
                    });
                },

                closeAttachmentModal() {
                    this.attachmentModalVisible = false;
                    this.currentAttachments = [];
                    this.currentAttachmentIndex = 0;
                    document.body.style.overflow = '';

                    // Clean up print event listeners
                    const preventPrint = (e) => {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        e.stopPropagation();
                        return false;
                    };
                    window.removeEventListener('beforeprint', preventPrint, true);
                    window.removeEventListener('print', preventPrint, true);
                    document.removeEventListener('beforeprint', preventPrint, true);
                    document.removeEventListener('print', preventPrint, true);
                },

                updateAttachmentViewer() {
                    if (this.currentAttachments.length === 0) return;

                    const attachment = this.currentAttachments[this.currentAttachmentIndex];
                    const url = attachment.url || attachment.path;
                    const isPDF = attachment.mimetype === 'application/pdf';
                    const isImage = attachment.mimetype && attachment.mimetype.startsWith('image/');

                    // Update download button
                    const downloadBtn = document.getElementById('facultyArchiveDownloadBtn');
                    if (downloadBtn) {
                        downloadBtn.href = url;
                        downloadBtn.download = attachment.filename || 'attachment';
                    }

                    // Update viewer content
                    const contentEl = document.getElementById('facultyArchiveAttachmentContent');
                    if (contentEl) {
                        if (isImage) {
                            contentEl.innerHTML = `<img src="${url}" alt="${attachment.filename}" style="max-width: 100%; max-height: calc(90vh - 200px); height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" />`;
                        } else if (isPDF) {
                            // Intercept print events immediately to prevent print dialog
                            const preventPrint = (e) => {
                                e.preventDefault();
                                e.stopImmediatePropagation();
                                e.stopPropagation();
                                return false;
                            };

                            // Add event listeners immediately before any PDF loading
                            window.addEventListener('beforeprint', preventPrint, true);
                            window.addEventListener('print', preventPrint, true);
                            document.addEventListener('beforeprint', preventPrint, true);
                            document.addEventListener('print', preventPrint, true);

                            // Use simple iframe to preview PDF - Edge blocks object/embed with sandbox
                            // Show loading state first
                            contentEl.innerHTML = `
                                <div style="display: flex; align-items: center; justify-content: center; height: calc(90vh - 200px); background: #f9fafb;">
                                    <div style="text-align: center;">
                                        <div style="width: 48px; height: 48px; border: 4px solid #e5e7eb; border-top-color: #2563eb; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
                                        <p style="color: #6b7280; margin: 0;">Loading PDF preview...</p>
                                    </div>
                                </div>
                                <style>
                                    @keyframes spin {
                                        to { transform: rotate(360deg); }
                                    }
                                </style>
                            `;

                            // Load PDF after modal is fully visible
                            // Use simple iframe without sandbox to avoid Edge blocking
                            setTimeout(() => {
                                const iframe = document.createElement('iframe');
                                // Add parameters to PDF URL to prevent print dialog
                                const pdfUrl = url.includes('#')
                                    ? url + '&toolbar=1&navpanes=0'
                                    : url + '#toolbar=1&navpanes=0';
                                iframe.src = pdfUrl;
                                iframe.style.cssText = 'width: 100%; height: calc(90vh - 200px); border: none; border-radius: 8px; display: block;';
                                iframe.title = attachment.filename;
                                iframe.setAttribute('allow', 'fullscreen');

                                // Prevent print when iframe loads
                                iframe.onload = function() {
                                    try {
                                        const iframeWindow = iframe.contentWindow;
                                        if (iframeWindow) {
                                            iframeWindow.addEventListener('beforeprint', preventPrint, true);
                                            iframeWindow.addEventListener('print', preventPrint, true);
                                        }
                                    } catch (e) {
                                        // Cross-origin restrictions - ignore
                                    }
                                };

                                contentEl.innerHTML = '';
                                contentEl.appendChild(iframe);

                                this.$nextTick(() => this.refreshLucideIcons());
                            }, 200);
                        } else {
                            contentEl.innerHTML = `
                                <div style="padding: 3rem; text-align: center;">
                                    <i data-lucide="file" style="width: 64px; height: 64px; color: #9ca3af; margin-bottom: 1rem;"></i>
                                    <p style="color: #6b7280; margin: 0.5rem 0;">This file type cannot be previewed.</p>
                                    <a href="${url}" download="${attachment.filename}" style="display: inline-block; margin-top: 1rem; padding: 0.75rem 1.5rem; background: #2563eb; color: white; text-decoration: none; border-radius: 8px; font-weight: 500;">Download File</a>
                                </div>
                            `;
                        }
                    }

                    // Update file info
                    const fileNameEl = document.getElementById('facultyArchiveFileName');
                    const fileSizeEl = document.getElementById('facultyArchiveFileSize');
                    if (fileNameEl) {
                        fileNameEl.textContent = attachment.filename || 'Attachment';
                    }
                    if (fileSizeEl) {
                        const size = attachment.size || 0;
                        const formatSize = size < 1024 ? size + ' B' :
                                          size < 1024 * 1024 ? (size / 1024).toFixed(1) + ' KB' :
                                          (size / (1024 * 1024)).toFixed(1) + ' MB';
                        fileSizeEl.textContent = `${formatSize} â€¢ ${this.currentAttachmentIndex + 1} of ${this.currentAttachments.length}`;
                    }

                    // Show/hide navigation buttons
                    const prevBtn = document.getElementById('facultyArchivePrevBtn');
                    const nextBtn = document.getElementById('facultyArchiveNextBtn');
                    if (prevBtn) {
                        prevBtn.style.display = this.currentAttachments.length > 1 ? 'block' : 'none';
                    }
                    if (nextBtn) {
                        nextBtn.style.display = this.currentAttachments.length > 1 ? 'block' : 'none';
                    }

                    this.$nextTick(() => this.refreshLucideIcons());
                },

                prevAttachment() {
                    if (this.currentAttachmentIndex > 0) {
                        this.currentAttachmentIndex--;
                        this.updateAttachmentViewer();
                    }
                },

                nextAttachment() {
                    if (this.currentAttachmentIndex < this.currentAttachments.length - 1) {
                        this.currentAttachmentIndex++;
                        this.updateAttachmentViewer();
                    }
                }
            },
            watch: {
                filteredMemos() {
                    this.$nextTick(() => this.refreshLucideIcons());
                }
            }
        }).mount('#app');

        // Close viewer with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const app = document.querySelector('#app').__vue_app__;
                if (app && app._instance) {
                    const instance = app._instance;
                    const proxy = instance.proxy || instance.ctx || instance;
                    const closeViewerFn =
                        (instance.exposed && instance.exposed.closeViewer) ||
                        (instance.setupState && instance.setupState.closeViewer) ||
                        (proxy && proxy.closeViewer);
                    const viewerVisible =
                        (proxy && typeof proxy.viewerVisible !== 'undefined' && proxy.viewerVisible) ||
                        (instance.setupState && instance.setupState.viewerVisible);

                    if (viewerVisible && typeof closeViewerFn === 'function') {
                        closeViewerFn.call(proxy);
                    }
                }
            }
        });
    </script>
    <script src="/js/log-viewer.js"></script>
</body>
</html>

